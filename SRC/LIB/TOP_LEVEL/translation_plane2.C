// translation_plane2.C
// 
// Anton Betten
// November 17, 2009
//
// 
//
// moved here from translation_plane.C: April 23, 2013
// moved to TOP_LEVEL: November 2, 2013
//
//

#include "orbiter.h"

void translation_plane::print_isomorphism_type(isomorph *Iso, 
	INT iso_cnt, sims *Stab, schreier &Orb, 
	INT *data, INT verbose_level)
// called from callback_print_isomorphism_type()
{
	INT f_v = (verbose_level >= 1);
	//INT f_implicit_fusion = FALSE;
	BYTE fname[1000];
	BYTE fname_klein[1000];
	INT f_elements_exponential = FALSE;
	const BYTE *symbol_for_print = "\\alpha";
	INT i, p, h;
	longinteger_object so;
	action *AA; // the action induced on the set
	INT *pt_list;
	INT f, l, j, idx, pt;

	AA = Orb.A;


	factor_prime_power(q, p, h);
	if (h > 1) {
		f_elements_exponential = TRUE;
		}

	if (f_v) {
		cout << "translation_plane::print_isomorphism_type" << endl;
		}

	sprintf(fname, "%s_%ld.tex", Iso->prefix, iso_cnt);
	sprintf(fname_klein, "%s_%ld_klein.tex", Iso->prefix, iso_cnt);
	
	INT save_longinteger_f_print_scientific = longinteger_f_print_scientific;
	longinteger_f_print_scientific = FALSE;
	{
	ofstream file(fname);
	//ofstream file_klein(fname_klein);
	if (f_v) {
		cout << "opening file " << fname << " for writing" << endl;
		//cout << "opening file " << fname_klein << " for writing" << endl;
		}

	latex_head(file, FALSE/* f_book*/, FALSE /* f_title */, NULL /*title*/, 
		"Anton Betten" /*BYTE *author*/, FALSE/* f_toc*/, 
		FALSE /* f_landscape*/,
		FALSE /* f_12pt */, 
		TRUE /* f_enlarged_page */, 
		TRUE /* f_pagenumbers */);
	
	
	file << "\\parindent=0pt" << endl;
	file << endl;
	file << "\\section{Spread " << iso_cnt << "}" << endl; 
	//INT_vec_print(file, data, q + 1);
	//file << endl;
	
	Stab->group_order(so);

	classify C;


	C.init(Orb.orbit_len, Orb.nb_orbits, FALSE, 0);

	file << "Stabilizer has order " << so << "\\\\" << endl;
	
	file << "\\bigskip" << endl;

	file << "There are $" << Orb.nb_orbits << "$ orbits on the set.\\\\" << endl;
	file << "The orbit type is $[";
	C.print_naked_tex(file, FALSE /*f_backwards*/);
	file << "]$\\\\" << endl;
	file << "\\bigskip" << endl;
	

	if (k == 2) {
		klein(file, /*file_klein,*/ Iso, iso_cnt, Stab, Orb, data, Iso->size,  verbose_level);
		}

	file << "The set of " << k - 1 << "-Subspaces in PG($" << n - 1 << ", " << q << "$) is:\\\\" << endl;
	
	for (i = 0; i < Iso->size; i++) {
		file << "$S_{" << i + 1 << "}$ has rank " << data[i] << " and is generated by\\\\" << endl;
		Grass->unrank_INT(data[i], 0);
		file << "$$" << endl;
		file << "\\left[" << endl;
		F->latex_matrix(file, f_elements_exponential, symbol_for_print, 
			Grass->M, k, n);
		file << "\\right]" << endl;
		file << "$$" << endl << endl;
		}

	file << "The stabilizer of order " << so << " is generated by:\\\\" << endl;
	for (i = 0; i < Stab->gens.len; i++) {
		
		INT *fp, n;
		
		fp = NEW_INT(A->degree);
		n = A->find_fixed_points(Stab->gens.ith(i), fp, 0);
		//cout << "with " << n << " fixed points" << endl;
		FREE_INT(fp);

		file << "$$ g_{" << i + 1 << "}=" << endl;
		A->element_print_latex(Stab->gens.ith(i), file);
		file << "$$" << endl << "with " << n << " fixed points" << endl;
		}



	if (f_v) {
		cout << "translation_plane::print_isomorphism_type calling induced_action_on_set_and_kernel" << endl;
		}
	Iso->induced_action_on_set_and_kernel(file, A, Stab, Iso->size, data, verbose_level - 1);

	if (f_v) {
		cout << "translation_plane::print_isomorphism_type induced_action_on_set_and_kernel finished" << endl;
		}


#if 0
	for (i = 0; i < Stab->gens.len; i++) {
		file << "$g_{" << setw(2) << i + 1 << "} = ";
		AA->element_print_as_permutation_with_offset(Stab->gens.ith(i), file, 1);
		file << "$\\\\" << endl;
		}
#endif
	
	pt_list = NEW_INT(Iso->size);
	
	file << "The orbits on the set are:\\\\" << endl;
	for (i = 0; i < Orb.nb_orbits; i++) {
		f = Orb.orbit_first[i];
		l = Orb.orbit_len[i];
		file << "$O_{" << i << "}=\\{";
		for (j = 0; j < l; j++) {
			idx = f + j;
			pt = Orb.orbit[idx];
			pt_list[j] = pt;
			}
		
		INT_vec_sort(l, pt_list);
		
		for (j = 0; j < l; j++) {		
			file << pt_list[j] + 1;
			if (j < l - 1)
				file << ",";
			}
		file << "\\}$ (length $" << l << "$)\\\\" << endl;
		}

#if 0
	
	if (Orb.nb_orbits > 1) {
		file << "\\bigskip" << endl;
		file << "The actions induced on the orbits are:\\\\" << endl;
	
		for (i = 0; i < Orb.nb_orbits; i++) {
			induced_action_on_orbit(file, AA, Stab, Orb, i, verbose_level - 2);
			}
		}
#endif



	FREE_INT(pt_list);
	




	latex_foot(file);
	longinteger_f_print_scientific = save_longinteger_f_print_scientific;
	}

	if (f_v) {
		cout << "translation_plane::print_isomorphism_type written file " << fname << " of size " << file_size(fname) << endl;
		cout << "translation_plane::print_isomorphism_type written file " << fname_klein << " of size " << file_size(fname_klein) << endl;
		}



}

void translation_plane::klein_plane_intersections(INT *data, INT data_size, 
	longinteger_object *&R,
	INT **&Pts_on_plane, 
	INT *&nb_pts_on_plane, 
	INT &nb_planes, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	projective_space *P3;
	projective_space *P5;
	INT i, j, a, b, c, e;
	INT *pi, *pj;
	INT N;
	INT d = 6;
	//INT f_semilinear = TRUE;
	INT *v;
	INT *the_set_out;
	INT set_size;
	INT *coords; // [set_size * 6]
	grassmann *Gr;

	if (f_v) {
		cout << "translation_plane::klein_plane_intersections" << endl;
		}
	set_size = data_size;
	P3 = new projective_space;
	
	P3->init(3, F, 
		//FALSE /* f_init_group */, 
		//FALSE /* f_line_action */, 
		FALSE /* f_init_incidence_structure */, 
		//TRUE /* f_semilinear */, 
		//FALSE /* f_basis */,
		0 /* verbose_level - 2 */);

	P5 = new projective_space;
	
	P5->init(5, F, 
		//FALSE /* f_init_group */, 
		//FALSE /* f_line_action */, 
		TRUE /* f_init_incidence_structure */, 
		//TRUE /* f_semilinear */, 
		//FALSE /* f_basis */,
		0 /* verbose_level - 2 */);

	the_set_out = NEW_INT(set_size);
	
	P3->klein_correspondence(P5, 
		data, set_size, the_set_out, 0/*verbose_level*/);



	if (f_v) {
		cout << "translation_plane::klein_plane_intersections after P3->klein_correspondence" << endl;
		}
	coords = NEW_INT(set_size * 6);
	for (i = 0; i < set_size; i++) {
		P5->unrank_point(coords + i * 6, the_set_out[i]);
		}
	if (FALSE && f_v) {
		cout << "The points are:" << endl;
		INT_matrix_print(coords, set_size, 6);
		}

#if 0
	BYTE fname_klein[1000];

	sprintf(fname_klein, "klein_q%ld_%ld.txt", q, iso_cnt);
	{

		ofstream f(fname_klein);
		f << set_size << endl;
		for (i = 0; i < set_size; i++) {
			pi = coords + i * 6;
			for (j = 0; j < 6; j++) {
				f << pi[j] << " ";
				}
			f << endl;
			}
		
	}
	cout << "Written file " << fname_klein << " of size " << file_size(fname_klein) << endl;
#endif

	for (i = 0; i < set_size; i++) {
		pi = coords + i * 6;
		for (j = i + 1; j < set_size; j++) {
			pj = coords + j * 6;
			a = F->mult(pi[0], pj[1]);
			b = F->mult(pi[1], pj[0]);
			e = F->add(a, b);
			a = F->mult(pi[2], pj[3]);
			b = F->mult(pi[3], pj[2]);
			c = F->add(a, b);
			e = F->add(e, c);
			a = F->mult(pi[4], pj[5]);
			b = F->mult(pi[5], pj[4]);
			c = F->add(a, b);
			e = F->add(e, c);
			if (e == 0) {
				cout << "not an ovoid, i=" << i << " j=" << j << " form value=" << e << endl;
				cout << "pi=";
				INT_vec_print(cout, pi, 6);
				cout << endl;
				cout << "pj=";
				INT_vec_print(cout, pj, 6);
				cout << endl;
				exit(1);
				}
			}
		}
	if (f_v) {
		cout << "translation_plane::klein_plane_intersections The Klein-image forms an ovoid." << endl;
		}
	
	v = NEW_INT(d);

	N = P5->nb_rk_k_subspaces_as_INT(3);
	if (f_v) {
		cout << "translation_plane::klein_plane_intersections N = " << N << endl;
		}

	

	Gr = new grassmann;

	Gr->init(6, 3, F, 0 /* verbose_level */);

	if (f_v) {
		cout << "translation_plane::klein_plane_intersections before plane_intersection_type_fast" << endl;
		}
	P5->plane_intersection_type_fast(Gr, the_set_out, set_size, 
		R, Pts_on_plane, nb_pts_on_plane, nb_planes, 
		verbose_level - 3);


	if (f_v) {
		cout << "translation_plane::klein_plane_intersections: We found " << nb_planes << " planes." << endl;
#if 1
		for (i = 0; i < nb_planes; i++) {
			cout << setw(3) << i << " : " << R[i] 
				<< " : " << setw(5) << nb_pts_on_plane[i] << " : ";
			INT_vec_print(cout, Pts_on_plane[i], nb_pts_on_plane[i]);
			cout << endl; 
			}
#endif
		}

#if 0
	delete [] R;
	for (i = 0; i < nb_planes; i++) {
		FREE_INT(Pts_on_plane[i]);
		}
	FREE_PINT(Pts_on_plane);
	FREE_INT(nb_pts_on_plane);
#endif
	FREE_INT(the_set_out);
	delete Gr;
	delete P3;
	delete P5;
	FREE_INT(v);
	FREE_INT(coords);
	if (f_v) {
		cout << "translation_plane::klein_plane_intersections done" << endl;
		}
}

void translation_plane::save_klein_invariants(BYTE *prefix, 
	INT iso_cnt, 
	INT *data, INT data_size, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	longinteger_object *R;
	INT **Pts_on_plane;
	INT *nb_pts_on_plane;
	INT nb_planes;
	INT i, j;

	if (f_v) {
		cout << "translation_plane::klein_invariants" << endl;
		}
	
	klein_plane_intersections(data, data_size, 
		R,
		Pts_on_plane, 
		nb_pts_on_plane, 
		nb_planes, 
		verbose_level - 2);

	Vector v;

	v.m_l(3);
	v.m_ii(0, nb_planes);
	v.s_i(1).change_to_vector();
	v.s_i(2).change_to_vector();

	v.s_i(1).as_vector().m_l(nb_planes);
	v.s_i(2).as_vector().m_l(nb_planes);
	for (i = 0; i < nb_planes; i++) {
		v.s_i(1).as_vector().m_ii(i, R[i].as_INT());
		//v.s_i(1).as_vector().s_i(i).change_to_longinteger();
		//v.s_i(1).as_vector().s_i(i).as_longinteger().allocate(1, R[i].rep());
		v.s_i(2).as_vector().s_i(i).change_to_vector();
		v.s_i(2).as_vector().s_i(i).as_vector().m_l(nb_pts_on_plane[i]);
		for (j = 0; j < nb_pts_on_plane[i]; j++) {
			v.s_i(2).as_vector().s_i(i).as_vector().m_ii(j, Pts_on_plane[i][j]);
			}
		}

	BYTE fname[1000];
	
	sprintf(fname, "%s%ld_klein_invariant.bin", prefix, iso_cnt);
	v.save_file(fname);

	delete [] R;
	for (i = 0; i < nb_planes; i++) {
		FREE_INT(Pts_on_plane[i]);
		}
	FREE_PINT(Pts_on_plane);
	FREE_INT(nb_pts_on_plane);

	if (f_v) {
		cout << "translation_plane::klein_invariants done" << endl;
		}
}

void translation_plane::klein(ofstream &ost, 
	isomorph *Iso, 
	INT iso_cnt, sims *Stab, schreier &Orb, 
	INT *data, INT data_size, INT verbose_level)
// Called from print_isomorphism_type if k == 2
{
	INT f_v = (verbose_level >= 1);
	longinteger_object *R;
	INT **Pts_on_plane;
	INT *nb_pts_on_plane;
	INT nb_planes;



	INT set_size = data_size;
	INT a, i, j, h;
	
	klein_plane_intersections(data, data_size, 
		R,
		Pts_on_plane, 
		nb_pts_on_plane, 
		nb_planes, 
		verbose_level);

	classify C;
	INT f_second = FALSE;

	C.init(nb_pts_on_plane, nb_planes, f_second, 0);
	if (f_v) {
		cout << "translation_plane::klein: plane-intersection type: ";
		C.print(FALSE /*f_backwards*/);
		}
	
	ost << "Plane type of Klein-image is $($ ";
	C.print_naked_tex(ost, FALSE /*f_backwards*/);
	ost << " $)$" << endl << endl;
	ost << "\\bigskip" << endl << endl;

	INT nb_blocks, f, l, m, u, uu, idx;
	INT *Inc;
	
	m = 0;
	for (i = 0; i < C.nb_types; i++) {
		f = C.type_first[i];
		l = C.type_len[i];
		a = C.data_sorted[f];
		m = MAXIMUM(a, m);
		}

	nb_blocks = 0;
	for (i = 0; i < C.nb_types; i++) {
		f = C.type_first[i];
		l = C.type_len[i];
		a = C.data_sorted[f];
		if (a == m) {
			nb_blocks += l;
			}
		}
	if (f_v) {
		cout << "There are " << nb_blocks << " interesting planes" << endl;
		}
	Inc = NEW_INT(set_size * nb_blocks);
	for (i = 0; i < set_size * nb_blocks; i++) {
		Inc[i] = 0;
		}
	j = 0;
	for (h = 0; h < C.nb_types; h++) {
		f = C.type_first[h];
		l = C.type_len[h];
		a = C.data_sorted[f];
		if (a == m) {
			for (u = 0; u < l; u++) {
				a = C.data_sorted[f + u];
				idx = C.sorting_perm_inv[f + u];
				for (uu = 0; uu < a; uu++) {
					i = Pts_on_plane[idx][uu];
					Inc[i * nb_blocks + j] = 1;
					}
				j++;
				} // next u
			} // if
		} // next h	

	if (nb_blocks < 20) {

		cout << "we will draw an incidence picture" << endl;
		
		BYTE fname_pic[1000];
		incidence_structure *I;
		partitionstack *Stack;
		
		I = new incidence_structure;
		I->init_by_matrix(set_size, nb_blocks, Inc, 0 /* verbose_level */);
		Stack = new partitionstack;
		Stack->allocate(set_size + nb_blocks, 0 /* verbose_level */);
		Stack->subset_continguous(set_size, nb_blocks);
		Stack->split_cell(0 /* verbose_level */);
		Stack->sort_cells();

		sprintf(fname_pic, "%s_%ld_planes.tex", Iso->prefix, iso_cnt);
		{
			ofstream fp_pic(fname_pic);

			ost << "\\input " << fname_pic << endl;
			I->latex_it(fp_pic, *Stack);
			ost << "\\\\" << endl;
		}
		delete Stack;
		delete I;
		}

	// compute TDO:
	{
		incidence_structure *I;
		partitionstack *Stack;
		INT depth = INT_MAX;
		
		I = new incidence_structure;
		I->init_by_matrix(set_size, nb_blocks, Inc, 0 /* verbose_level */);
		Stack = new partitionstack;
		Stack->allocate(set_size + nb_blocks, 0 /* verbose_level */);
		Stack->subset_continguous(set_size, nb_blocks);
		Stack->split_cell(0 /* verbose_level */);
		Stack->sort_cells();

		I->compute_TDO_safe(*Stack, depth, verbose_level + 2);
		
		BYTE fname_row_scheme[1000];
		BYTE fname_col_scheme[1000];

		sprintf(fname_row_scheme, "%s_%ld_planes_row_scheme.tex", Iso->prefix, iso_cnt);
		sprintf(fname_col_scheme, "%s_%ld_planes_col_scheme.tex", Iso->prefix, iso_cnt);
		{
		ofstream fp_row_scheme(fname_row_scheme);
		ofstream fp_col_scheme(fname_col_scheme);
		I->get_and_print_row_tactical_decomposition_scheme_tex(
			fp_row_scheme, FALSE /* f_enter_math */, *Stack);
		I->get_and_print_column_tactical_decomposition_scheme_tex(
			fp_col_scheme, FALSE /* f_enter_math */, *Stack);
		}


#if 0
		ost2 << "\\section*{Spread " << iso_cnt << "}" << endl << endl;

		longinteger_object go;
		Stab->group_order(go);

		ost2 << "Stabilizer has order " << go << "\\\\" << endl;
	
		ost2 << "\\bigskip" << endl;


		classify C0;
		C0.init(Orb.orbit_len, Orb.nb_orbits, FALSE, 0);
		
		ost2 << "There are $" << Orb.nb_orbits << "$ orbits on the set.\\\\" << endl;
		ost2 << "The orbit type is $[";
		C0.print_naked_tex(ost2);
		ost2 << "]$\\\\" << endl;
		ost2 << "\\bigskip" << endl;

		ost2 << "Plane type of Klein-image is $(";
		C.print_naked_tex(ost2);
		ost2 << ")$" << endl << endl;
#endif


		ost << "\\bigskip" << endl << endl;
		ost << "\\[" << endl;
		ost << "\\input " << fname_row_scheme << endl;
		ost << "\\quad" << endl;
		ost << "\\input " << fname_col_scheme << endl;
		ost << "\\]" << endl;

#if 0
		ost2 << "\\bigskip" << endl << endl;
		ost2 << "\\[" << endl;
		ost2 << "\\input " << fname_row_scheme << endl;
		ost2 << "\\quad" << endl;
		ost2 << "\\input " << fname_col_scheme << endl;
		ost2 << "\\]" << endl;
#endif
		delete Stack;
		delete I;
	}

	FREE_INT(Inc);
	
	delete [] R;
	for (i = 0; i < nb_planes; i++) {
		FREE_INT(Pts_on_plane[i]);
		}
	FREE_PINT(Pts_on_plane);
	FREE_INT(nb_pts_on_plane);

	if (f_v) {
		cout << "translation_plane::klein done" << endl;
		}
}

void translation_plane::test_plane_intersection_type_of_klein_image(
	const BYTE *fname, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	//INT f_vv = (verbose_level >= 2);
	projective_space *P3;
	projective_space *P5;
	grassmann *Gr;
	INT *intersection_type;
	INT highest_intersection_number;
	INT *data;
	INT size;

	if (f_v) {
		cout << "translation_plane::test_plane_intersection_type_of_klein_image" << endl;
		}
	P3 = new projective_space;
	
	P3->init(3, F, 
		//FALSE /* f_init_group */, 
		//FALSE /* f_line_action */, 
		FALSE /* f_init_incidence_structure */, 
		//TRUE /* f_semilinear */, 
		//FALSE /* f_basis */,
		0 /* verbose_level - 2 */);
	//F = P->F;

	P5 = new projective_space;
	
	P5->init(5, F, 
		//FALSE /* f_init_group */, 
		//FALSE /* f_line_action */, 
		TRUE /* f_init_incidence_structure */, 
		//TRUE /* f_semilinear */, 
		//FALSE /* f_basis */,
		0 /* verbose_level - 2 */);

	Gr = new grassmann;

	Gr->init(6, 3, F, 0 /* verbose_level */);

#if 0
	INT a, i, cnt;
	size = order + 1;
	data = NEW_INT(size);
	{
		ifstream f(fname);

		cnt = 0;
		while (TRUE) {
			f >> a;
			if (a == -1) {
				break;
				}
			for (i = 0; i < size; i++) {
				f >> data[i];
				}
			
			if (f_vv) {
				cout << "cnt=" << cnt << " : ";
				INT_vec_print(cout, data, size);
				cout << endl;
				}
			
			plane_intersection_type_of_klein_image(P3, P5, Gr, data, size, 
				intersection_type, highest_intersection_number, 
				verbose_level - 2);
			
			cout << cnt << " : ";
			INT_vec_print(cout, intersection_type, highest_intersection_number + 1);
			cout << endl;


			FREE_INT(intersection_type);
			cnt++;
			} // while

	}
	FREE_INT(data);
#else
	read_set_from_file(fname, data, size, verbose_level);

#if 0
	if (size != order + 1) {
		cout << "size != order + 1" << endl;
		exit(1);
		}
#endif

	plane_intersection_type_of_klein_image(P3, P5, Gr, data, size, 
		intersection_type, highest_intersection_number, 
		verbose_level - 2);
			
	INT_vec_print(cout, intersection_type, highest_intersection_number + 1);
	cout << endl;


	INT *points;
	INT i, j, a, b;

	points = NEW_INT(size * (q + 1));
	for (i = 0; i < size; i++) {
		a = data[i];
		if (!P3->Lines) {
			cout << "!P3->Lines" << endl;
			exit(1);
			}
		for (j = 0; j < q + 1; j++) {
			b = P3->Lines[a * P3->k + j];
			points[i * P3->k + j] = b;
			}
		}

	if (FALSE) {
		cout << "points:" << endl;
		INT_matrix_print(points, size, q + 1);
		cout << endl;
		}

	if (size == order + 1) {
		cout << "Testing spread property" << endl;
		INT_vec_heapsort(points, size * (q + 1));
		for (i = 0; i < P3->N_points; i++) {
			if (points[i] != i) {
				cout << "Not a spread" << endl;
				cout << "points[" << i << "]=" << points[i] << endl;
				exit(1);
				}
			}
		}


	FREE_INT(intersection_type);
	FREE_INT(data);
#endif


	delete P3;
	delete P5;
	delete Gr;
}

void translation_plane::plane_intersection_type_of_klein_image(
	projective_space *P3, 
	projective_space *P5, 
	grassmann *Gr, 
	INT *data, INT size, 
	INT *&intersection_type, INT &highest_intersection_number, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_v3 = FALSE; //(verbose_level >= 3);
	finite_field *F;
	INT N;
	INT *the_set_out;

	if (f_v) {
		cout << "translation_plane::plane_intersection_type_of_klein_image" << endl;
		}
	the_set_out = NEW_INT(size);
	
	if (f_v3) {
		P3->print_line_set_numerical(data, size);
		}
	P3->klein_correspondence(P5, 
		data, size, the_set_out, 0/*verbose_level*/);
	if (f_v) {
		cout << "after Klein correspondence:" << endl;
		INT_vec_print(cout, the_set_out, size);
		cout << endl;
		}
	if (f_v3) {
		P5->print_set_numerical(the_set_out, size);
		}


	F = P3->F;

	if (f_v) {
		cout << "translation_plane::plane_intersection_type_of_klein_image after P3->klein_correspondence" << endl;
		}

	
	N = P5->nb_rk_k_subspaces_as_INT(3);
	if (f_v) {
		cout << "translation_plane::klein N = " << N << endl;
		}


	P5->plane_intersection_type(Gr, 
		the_set_out, size, 
		intersection_type, highest_intersection_number, 
		verbose_level - 2);

	FREE_INT(the_set_out);
}

void translation_plane::czerwinski_oakden(INT level, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT sz = 26;
	INT data[26];
	INT M[8];
	INT h, u, i, a, b,c, d;
	INT spreads[] = 	
		{
			// S1:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			4,3,3,0,
			0,3,3,1,
			2,1,1,4,
			4,4,4,2,
			2,3,3,3,
			3,4,4,1,
			1,1,1,3,
			3,2,2,2,
			0,1,1,2,
			1,2,2,0,
			0,2,2,4,
			2,4,4,0,
			0,4,4,3,
			3,1,1,0,
			1,4,4,4,
			4,2,2,3,
			3,3,3,4,
			4,1,1,1,
			1,3,3,2,
			2,2,2,1,

			//S2:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			1,2,2,0,
			0,2,2,4,
			4,3,3,0,
			0,3,3,1,
			2,1,3,3,
			4,4,4,1,
			2,3,1,3,
			3,4,2,2,
			1,1,1,4,
			3,2,4,2,
			0,1,1,2,
			2,4,4,0,
			0,4,4,3,
			3,1,1,0,
			1,4,4,4,
			4,2,2,3,
			3,3,3,4,
			4,1,1,1,
			1,3,3,2,
			2,2,2,1,

			// S3:
			0,0,0,0,
			1,0,0,1,
			1,2,2,0,
			0,2,2,4,
			4,0,0,4,
			4,3,3,0,
			0,3,3,1,
			2,1,3,3,
			4,4,4,1,
			2,3,1,3,
			3,4,2,2,
			1,1,1,4,
			3,2,4,2,
			0,1,4,0,
			2,0,4,3,
			2,4,0,3,
			0,4,1,0,
			3,0,1,2,
			3,1,0,2,
			1,4,4,4,
			4,2,2,3,
			3,3,3,4,
			4,1,1,1,
			1,3,3,2,
			2,2,2,1,

			//S4:
			0,0,0,0,
			1,0,0,1,
			1,2,2,0,
			0,2,2,4,
			4,0,0,4,
			4,3,3,0,
			0,3,3,1,
			2,1,3,3,
			4,4,4,1,
			2,3,1,3,
			3,4,2,2,
			1,1,1,4,
			3,2,4,2, 
			0,1,1,2,
			2,0,0,2,
			2,4,4,0,
			0,4,4,3,
			3,0,0,3,
			3,1,1,0,
			1,4,3,4,
			4,2,1,1,
			3,3,3,2,
			4,1,2,1,
			1,3,4,4,
			2,2,2,3,

			// S5:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			0,2,1,0,
			0,3,4,0,
			1,1,3,1,
			1,4,2,1,
			4,1,3,4,
			4,4,2,4,
			1,2,1,4,
			1,3,4,4,
			2,1,2,0,
			2,2,4,3,
			2,3,3,3,
			2,4,1,3,
			3,1,4,2,
			3,2,2,2,
			3,3,1,2,
			3,4,3,0,
			4,2,1,1,
			4,3,4,1,
			0,1,2,3,
			0,4,3,2,

			// A1:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			1,1,3,1,
			4,4,2,4,
			1,4,2,1,
			4,1,3,4,
			3,2,1,3,
			2,2,1,2,
			3,3,4,3,
			2,3,4,2,
			4,2,4,4,
			1,3,1,1,
			3,4,3,0,
			2,1,2,0,
			0,4,3,3,
			0,1,2,2,
			1,2,4,0,
			4,3,1,0,
			2,4,3,2,
			3,1,2,3,
			0,2,4,1,
			0,3,1,4,

			//A2:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			2,2,1,2,
			0,3,4,0,
			0,1,3,0,
			4,1,3,4,
			2,4,2,2,
			3,4,2,3,
			3,2,3,1,
			4,3,2,1,
			3,1,4,2,
			2,1,4,1,
			4,4,1,0,
			0,4,1,1,
			1,1,1,3,
			1,4,4,4,
			2,3,3,3,
			1,3,3,2,
			0,2,2,4,
			1,2,2,0,
			4,2,4,3,
			3,3,1,4,

			//A3:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			1,3,4,1,
			2,3,4,2,
			4,2,1,4,
			2,4,4,2,
			1,4,2,1,
			2,2,3,0,
			3,2,3,1,
			3,3,2,0,
			0,1,4,4,
			4,1,4,3,
			4,4,2,3,
			0,4,2,4,
			1,1,3,2,
			1,2,1,3,
			0,2,1,2,
			2,1,1,0,
			3,1,1,1,
			3,4,4,0,
			0,3,3,4,
			4,3,3,3,
			
			// A4:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			2,2,1,2,
			0,3,4,0,
			4,1,3,4,
			3,4,2,3,
			3,2,3,1,
			3,1,4,2,
			2,1,4,1,
			4,4,1,0,
			1,4,4,4,
			2,3,3,3,
			0,2,2,4,
			1,2,2,0,
			4,2,4,3,
			3,3,1,4,
			2,4,2,1,
			0,1,1,3,
			4,3,2,2,
			1,1,3,0,
			1,3,1,1,
			0,4,3,2,
			
			// A5:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			0,1,3,0,
			1,2,1,4,
			2,3,3,3,
			3,4,1,2,
			1,3,4,4,
			4,3,4,2,
			0,4,2,4,
			3,1,3,4,
			0,2,4,0,
			3,2,4,3,
			2,1,2,2,
			1,4,3,1,
			4,1,2,1,
			1,1,2,3,
			2,2,4,1,
			0,3,1,1,
			2,4,1,3,
			4,4,1,0,
			3,3,2,0,
			4,2,3,2,

			//A6:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			4,2,1,1,
			1,3,4,4,
			3,4,2,2,
			3,2,1,0,
			0,2,1,2,
			2,2,2,3,
			3,3,3,2,
			1,1,1,4,
			2,3,3,1,
			4,3,3,3,
			0,1,3,0,
			0,4,2,0,
			0,3,4,0,
			4,4,2,4,
			1,4,2,1,
			2,4,1,3,
			3,1,4,2,
			1,2,3,4,
			2,1,4,1,
			4,1,4,3,

			//A7:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			2,2,2,3,
			1,3,3,0,
			1,4,4,3,
			2,1,1,0,
			4,2,1,1, 
			4,3,4,2,
			0,4,2,4,
			3,1,3,4,
			2,3,3,3,
			1,2,2,0,
			1,1,1,3,
			2,4,4,0,
			3,4,1,2,
			0,1,4,1,
			3,3,2,1,
			0,2,3,2,
			4,4,3,1,
			4,1,2,2,
			0,3,1,4,
			3,2,4,4,

			//A8:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,0,0,4,
			1,3,4,4,
			4,3,4,2,
			4,1,2,1,
			2,1,2,4,
			0,2,4,0,
			4,4,3,4,
			2,4,1,3,
			3,3,2,0,
			3,1,3,3,
			4,2,1,4,
			1,4,1,0,
			0,3,2,3,
			1,2,2,2,
			2,3,3,1,
			3,4,4,1,
			0,1,1,2,
			3,2,1,1,
			1,1,3,0,
			0,4,3,2,
			2,2,4,3,

			// B1:
			0,0,0,0,
			1,0,0,1,
			3,0,0,3,
			2,2,4,2,
			2,4,3,2,
			0,3,1,0,
			1,2,3,4,
			2,0,1,2,
			2,3,2,1,
			4,3,0,2,
			0,4,3,1,
			0,2,4,1,
			1,3,4,4,
			4,4,2,3,
			3,4,2,4,
			3,1,1,1,
			1,1,1,3,
			0,1,2,2,
			4,0,1,4,
			3,2,3,3,
			2,1,0,4,
			4,1,4,0,
			4,2,3,0,
			3,3,4,3,
			1,4,2,0,

			// B2:
			0,0,0,0,
			1,0,0,1,
			4,0,0,4,
			3,4,3,3,
			3,3,1,3,
			4,1,2,4,
			1,4,1,2,
			0,4,4,1,
			1,2,2,3,
			2,1,0,3,
			3,1,0,2,
			3,2,2,2,
			4,2,1,4,
			2,2,1,0,
			1,1,3,1,
			2,4,3,4,
			0,2,2,1,
			2,3,2,0,
			4,4,4,0,
			2,0,4,3,
			3,0,4,2,
			0,3,1,1,
			4,3,3,2,
			0,1,3,0,
			1,3,4,4,
			
			// B3:
			0,0,0,0,
			1,0,0,1,
			4,0,0,4,
			4,4,3,4,
			2,2,4,2,
			4,1,2,4,
			0,4,3,0,
			0,2,4,4,
			4,2,4,0,
			1,2,2,3,
			3,1,2,0,
			2,1,3,3,
			1,3,1,4,
			1,1,3,2,
			2,4,2,1,
			0,1,1,1,
			1,4,4,3,
			4,3,1,0,
			3,2,3,1,
			2,3,0,3,
			2,0,1,3,
			3,0,1,2,
			0,3,2,2,
			3,4,0,2,
			3,3,4,1,

			// B4:
			0,0,0,0,
			1,0,0,1,
			4,0,0,4,
			3,4,3,3,
			3,1,2,3,
			1,3,1,1,
			1,2,4,1,
			0,1,1,2,
			2,3,2,0,
			2,0,3,2,
			2,4,0,2,
			1,1,3,0,
			0,4,2,1,
			2,2,1,0,
			0,3,4,2,
			4,3,1,3,
			3,3,1,4,
			4,4,4,0,
			0,2,3,4,
			2,1,4,4,
			4,2,2,2,
			3,0,4,3,
			3,2,0,3,
			1,4,2,4,
			4,1,3,1,
			
			// B5:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			4,3,1,4,
			1,2,4,1,
			3,3,1,3,
			1,1,2,1,
			1,4,1,2,
			2,3,3,1,
			3,0,4,4,
			4,2,0,3,
			0,4,1,1,
			1,3,3,0,
			0,3,2,2,
			2,1,1,0,
			3,4,0,4,
			4,0,3,3,
			0,2,4,2,
			2,2,4,0,
			4,4,2,0,
			0,1,3,4,
			4,1,4,3,
			3,2,2,4,
			2,4,2,3,
			3,1,3,2,

			// B6:
			0,0,0,0,
			1,0,0,1,
			4,2,2,3,
			1,2,2,0,
			3,2,2,2,
			2,2,2,4,
			3,3,3,1,
			1,4,4,2,
			2,4,1,1,
			1,1,1,0,
			3,4,0,4,
			0,1,4,4,
			2,0,4,3,
			1,3,3,0,
			3,1,4,1,
			4,0,3,4,
			4,1,0,3,
			0,4,1,3,
			0,2,2,1,
			2,1,3,2,
			4,4,4,0,
			2,3,0,2,
			0,3,3,3,
			3,0,1,2,
			4,3,1,4,

			//B7:
			0,0,0,0,
			1,0,0,1,
			2,2,4,2,
			3,2,4,3,
			1,2,4,1,
			3,3,1,3,
			2,4,3,2,
			1,1,1,0,
			0,3,2,1,
			3,1,0,2,
			2,0,2,3,
			4,1,0,3,
			3,0,2,4,
			4,4,4,0,
			0,2,3,4,
			4,3,3,0,
			0,4,1,4,
			3,4,3,1,
			0,1,4,4,
			1,4,3,3,
			4,2,2,0,
			2,3,0,4,
			4,0,1,2,
			1,3,2,2,
			2,1,1,1,

			// B8:
			0,0,0,0,
			1,0,0,1,
			2,0,0,2,
			3,0,0,3,
			4,2,2,0,
			0,2,2,3,
			4,3,3,0,
			0,4,4,3,
			4,4,4,2,
			4,0,1,4,
			4,1,0,4,
			3,2,4,4,
			3,4,2,4,
			0,1,1,2,
			2,3,1,1,
			2,1,3,1,
			1,4,1,0,
			1,1,4,0,
			3,1,3,3,
			2,2,2,1,
			3,3,1,3,
			2,4,4,1,
			1,2,3,2,
			1,3,2,2,
			0,3,3,4,

		};

	if (f_v) {
		cout << "translation_plane::czerwinski_oakden" << endl;
		}

	const BYTE *label[] = {
		"S1", 
		"S2", 
		"S3", 
		"S4", 
		"S5", 
		"A1", 
		"A2", 
		"A3", 
		"A4", 
		"A5", 
		"A6", 
		"A7", 
		"A8", 
		"B1", 
		"B2", 
		"B3", 
		"B4", 
		"B5", 
		"B6", 
		"B7", 
		"B8", 
		};
	BYTE fname[] = "Czerwinski_Oakden.txt";
	BYTE fname2[1000];
	{
	ofstream fp(fname);
	
	for (h = 0; h < 21; h++) {
		for (u = 0; u < sz; u++) {
			for (i = 0; i < 8; i++) {
				M[i] = 0;
				}
			if (u == 0) {
				M[0 * 4 + 2] = 1;
				M[1 * 4 + 3] = 1;
				}
			else {
				M[0 * 4 + 0] = 1;
				M[1 * 4 + 1] = 1;
				a = spreads[h * 25 * 4 + (u - 1) * 4 + 0];
				b = spreads[h * 25 * 4 + (u - 1) * 4 + 1];
				c = spreads[h * 25 * 4 + (u - 1) * 4 + 2];
				d = spreads[h * 25 * 4 + (u - 1) * 4 + 3];
				M[0 * 4 + 2] = a;
				M[0 * 4 + 3] = b;
				M[1 * 4 + 2] = c;
				M[1 * 4 + 3] = d;
				}
			for (i = 0; i < 8; i++) {
				Grass->M[i] = M[i];
				}
			if (f_vv) {
				cout << "spread " << h << ", element " << u << ":" << endl;
				if (u) {
					cout << "a=" << a << " b=" << b << " c=" << c << " d=" << d << endl;
					}
				}
			INT_matrix_print(Grass->M, 2, 4);
			data[u] = Grass->rank_INT(0);

			} // next u

		cout << "spread " << h << ":";
		INT_vec_print(cout, data, sz);
		cout << endl;

		fp << "0 "; // a dummy
		for (i = 0; i < sz; i++) {
			fp << data[i] << " ";
			}
		fp << endl;

		sprintf(fname2, "Czerwinski_Oakden_%s.txt", label[h]);
		write_set_to_file(fname2, data, sz, 0/*verbose_level*/);
		cout << "Written file " << fname2 << " of size " << file_size(fname2) << endl;
		} // next h
	fp << -1 << endl;
	}
	cout << "Written file " << fname << " of size " << file_size(fname) << endl;
}

void translation_plane::write_spread_to_file(INT type_of_spread, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT *data;
	INT sz = order + 1;
	BYTE fname[1000];

	if (f_v) {
		cout << "translation_plane::write_spread_to_file" << endl;
		}
	if (type_of_spread == SPREAD_OF_TYPE_FTWKB) {
		sprintf(fname, "spread_q%ld_FTW.txt", q);
		}
	else if (type_of_spread == SPREAD_OF_TYPE_KANTOR) {
		sprintf(fname, "spread_q%ld_Kantor.txt", q);
		}
	else if (type_of_spread == SPREAD_OF_TYPE_KANTOR2) {
		sprintf(fname, "spread_q%ld_Kantor2.txt", q);
		}
	else if (type_of_spread == SPREAD_OF_TYPE_GANLEY) {
		sprintf(fname, "spread_q%ld_Ganley.txt", q);
		}
	else if (type_of_spread == SPREAD_OF_TYPE_LAW_PENTTILA) {
		sprintf(fname, "spread_q%ld_Law_Penttila.txt", q);
		}
	else if (type_of_spread == SPREAD_OF_TYPE_DICKSON_KANTOR) {
		sprintf(fname, "spread_q%ld_DicksonKantor.txt", q);
		}
	else if (type_of_spread == SPREAD_OF_TYPE_HUDSON) {
		sprintf(fname, "spread_q%ld_Hudson.txt", q);
		}

	data = NEW_INT(sz);
	if (type_of_spread == SPREAD_OF_TYPE_DICKSON_KANTOR ||
		type_of_spread == SPREAD_OF_TYPE_HUDSON) {
		make_spread(data, type_of_spread, verbose_level);
		}
	else {
		make_spread_from_q_clan(data, type_of_spread, verbose_level);
		}
	write_set_to_file(fname, data, sz, 0/*verbose_level*/);
	cout << "Written file " << fname << " of size " << file_size(fname) << endl;
	FREE_INT(data);
}

void translation_plane::make_spread(INT *data, INT type_of_spread, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT sz = order + 1;
	INT M[8];
	INT h, i, h1, s, t, sq, tq, x, y, w, z, eta, exponent;
	INT q1 = i_power_j(F->p, (F->e >> 1));

	if (f_v) {
		cout << "translation_plane::make_spread q=" << q << " q1=" << q1 << endl;
		}
	if (n != 4) {
		cout << "translation_plane::make_spread n != 4" << endl;
		exit(1);
		}
	if (EVEN(q)) {
		cout << "translation_plane::make_spread need q odd" << endl;
		exit(1);
		}
	if (k != 2) {
		cout << "translation_plane::make_spread k != 2" << endl;
		exit(1);
		}
	for (eta = q1; eta < q; eta++) {
		if (F->negate(F->power(eta, q1)) == eta) {
			if (f_v) {
				cout << "translation_plane::make_spread eta=" << eta << endl;
				}
			break;
			}
		}
	exponent = (F->q + 2 * q1 - 1) >> 1;
	for (h = 0; h < sz; h++) {
		for (i = 0; i < 8; i++) {
			M[i] = 0;
			}
		if (h == 0) {
			M[0 * 4 + 2] = 1;
			M[1 * 4 + 3] = 1;
			}
		else {
			M[0 * 4 + 0] = 1;
			M[1 * 4 + 1] = 1;
			h1 = h - 1;
			s = h1 % q;
			t = (h1 - s) / q;
			x = s;
			y = t;
			sq = F->power(s, q1);
			tq = F->power(t, q1);
			if (type_of_spread == SPREAD_OF_TYPE_DICKSON_KANTOR) {
				w = F->add(sq, tq);
				}
			else {
				w = F->add(sq, F->power(t, exponent));
				}
			z = F->add(F->mult(eta, sq), tq);
			M[0 * 4 + 2] = x;
			M[0 * 4 + 3] = y;
			M[1 * 4 + 2] = w;
			M[1 * 4 + 3] = z;
			}
		for (i = 0; i < 8; i++) {
			Grass->M[i] = M[i];
			}
		if (f_vv) {
			cout << "spread element " << h << ":" << endl;
			INT_matrix_print(Grass->M, 2, 4);
			}
		data[h] = Grass->rank_INT(0);
		} // next h
	if (check_function(sz, data, verbose_level - 2)) {
		if (f_v) {
			cout << "translation_plane::make_spread The set is a spread" << endl;
			}
		}
	else {
		cout << "translation_plane::make_spreadThe set is NOT a spread" << endl;
		exit(1);
		}

	if (f_v) {
		cout << "translation_plane::make_spread done" << endl;
		}
}


void translation_plane::make_spread_from_q_clan(INT *data, INT type_of_spread, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT sz = order + 1;
	INT M[8];
	INT h, h1, i, s, t, t2, t3, t4, t5, t7, t9, a_t, b_t, c_t, x, y, w, z, r;
	INT three, five, nonsquare, minus_nonsquare, nonsquare_inv;

	if (f_v) {
		cout << "translation_plane::make_spread_from_q_clan" << endl;
		}
	if (n != 4) {
		cout << "translation_plane::make_spread_from_q_clan n != 4" << endl;
		exit(1);
		}
	if (k != 2) {
		cout << "translation_plane::make_spread_from_q_clan k != 2" << endl;
		exit(1);
		}
	three = F->add3(1, 1, 1);
	five = F->add3(three, 1, 1);
	if (type_of_spread == SPREAD_OF_TYPE_KANTOR || 
		type_of_spread == SPREAD_OF_TYPE_GANLEY || 
		type_of_spread == SPREAD_OF_TYPE_LAW_PENTTILA) {
		nonsquare = F->alpha_power(1);	
		nonsquare_inv = F->inverse(nonsquare);	
		minus_nonsquare = F->negate(nonsquare);
		}
	for (h = 0; h < sz; h++) {
		for (i = 0; i < 8; i++) {
			M[i] = 0;
			}
		if (h == 0) {
			M[0 * 4 + 2] = 1;
			M[1 * 4 + 3] = 1;
			}
		else {
			M[0 * 4 + 0] = 1;
			M[1 * 4 + 1] = 1;
			h1 = h - 1;
			s = h1 % q;
			t = (h1 - s) / q;

			// create the q-clan:

			if (type_of_spread == SPREAD_OF_TYPE_FTWKB) {
				// Fisher Thas Walker Betten:
				// a_t = t, b_t = 3t^2, c_t = 3t^3
				// only when q \equiv 2 mod 3
				r = q % 3;
				if (r != 2) {
					cout << "FTWKB needs q equiv 2 mod 3" << endl;
					exit(1);
					}
				a_t = t;
				b_t = F->product3(three, t, t);
				c_t = F->mult(b_t, t);
				}
			else if (type_of_spread == SPREAD_OF_TYPE_KANTOR) {
				if (EVEN(q)) {
					cout << "KANTOR needs q to be odd" << endl;
					exit(1);
					}
				if (is_prime(q)) {
					cout << "KANTOR needs q to be a prime power" << endl;
					exit(1);
					}
				a_t = t;
				b_t = 0;
				c_t = F->mult(minus_nonsquare, F->frobenius_power(t, 1));
				}
			else if (type_of_spread == SPREAD_OF_TYPE_KANTOR2) {
				if (EVEN(q)) {
					cout << "KANTOR2 needs q to be odd" << endl;
					exit(1);
					}
				if ((q % 5) != 2 && (q % 5) != 3) {
					cout << "KANTOR needs q congruent 2 or 3 mod 5" << endl;
					exit(1);
					}
				t3 = F->product3(t, t, t);
				t5 = F->product3(t3, t, t);
				a_t = t;
				b_t = F->mult(five, t3);
				c_t = F->mult(five, t5);
				}
			else if (type_of_spread == SPREAD_OF_TYPE_GANLEY) {
				INT tmp1, tmp2;
				if (q % 3) {
					cout << "GANLEY, q needs to be a power of three" << endl;
					exit(1);
					}
				t3 = F->product3(t, t, t);
				t9 = F->product3(t3, t3, t3);
				a_t = t;
				b_t = t3;
				tmp1 = F->mult(nonsquare, t);
				tmp2 = F->mult(nonsquare_inv, t9);
				c_t = F->negate(F->add(tmp1, tmp2));
				}
			else if (type_of_spread == SPREAD_OF_TYPE_LAW_PENTTILA) {
				INT tmp1, tmp2;
				INT n2, n3;
				if (q % 3) {
					cout << "LAW_PENTTILA, q needs to be a power of three" << endl;
					exit(1);
					}
				t2 = F->mult(t, t);
				t3 = F->product3(t, t, t);
				t4 = F->mult(t2, t2);
				t7 = F->mult(t4, t3);
				t9 = F->product3(t3, t3, t3);
				n2 = F->mult(nonsquare, nonsquare);
				n3 = F->product3(nonsquare, nonsquare, nonsquare);
				a_t = t;
				b_t = F->negate(F->add(t4, F->mult(nonsquare, t2)));
				tmp1 = F->add(t7, F->mult(n2, t3));
				tmp2 = F->negate(F->add(F->mult(nonsquare_inv, t9), F->mult(n3, t)));
				c_t = F->add(tmp1, tmp2);
				if (h == 34) {
					cout << "s=" << s << endl;
					cout << "t=" << t << endl;
					cout << "n=" << nonsquare << endl;
					cout << "t2=" << t2 << endl;
					cout << "t3=" << t3 << endl;
					cout << "t4=" << t4 << endl;
					cout << "t7=" << t7 << endl;
					cout << "t9=" << t9 << endl;
					cout << "a_t=" << a_t << endl;
					cout << "b_t=" << b_t << endl;
					cout << "c_t=" << c_t << endl;
					}
				}
			

			// create the spread element 
			// according to Gevaert-Johnson 1988:

			x = a_t;
			y = F->add(b_t, s);
			w = F->negate(s);
			z = c_t;
			M[0 * 4 + 2] = x;
			M[0 * 4 + 3] = y;
			M[1 * 4 + 2] = w;
			M[1 * 4 + 3] = z;
			}
		for (i = 0; i < 8; i++) {
			Grass->M[i] = M[i];
			}
		if (f_vv) {
			cout << "spread element " << h << ":" << endl;
			INT_matrix_print(Grass->M, 2, 4);
			}
		data[h] = Grass->rank_INT(0);
		}
	if (check_function(sz, data, verbose_level - 2)) {
		cout << "The set is a spread" << endl;
		}
	else {
		cout << "The set is NOT a spread" << endl;
		exit(1);
		}
}

void translation_plane::read_and_print_spread(const BYTE *fname, INT verbose_level)
{
	INT *data;
	INT sz;
	
	read_set_from_file(fname, data, sz, verbose_level);
	print_spread(data, sz);
	FREE_INT(data);
}

void translation_plane::HMO(const BYTE *fname, INT verbose_level)
{
	INT *data;
	INT sz, i, h, h1;
	INT *G, *H;
	INT *Ge, *He;
	INT *GG, *HH;
	INT alpha, beta, omega, x, y, tmp1, tmp2, f, z;
	INT M[8];
	
	if (order != q * q) {
		cout << "translation_plane::print_spread order != q * q" << endl;
		exit(1);
		}
	read_set_from_file(fname, data, sz, verbose_level);
	G = NEW_INT(order);
	H = NEW_INT(order);
	Ge = NEW_INT(order);
	He = NEW_INT(order);
	print_spread(data, sz);
	get_spread_matrices(G, H, data, verbose_level);


	INT q2;
	finite_field *Fq2;
	subfield_structure *Sub;

	q2 = q * q;
	Fq2 = new finite_field;
	Sub = new subfield_structure;
	Fq2->init(q2, verbose_level);
	Sub->init(Fq2, F, verbose_level);
	for (i = 0; i < q * q; i++) {
		Ge[i] = Sub->FQ_embedding[G[i]];
		He[i] = Sub->FQ_embedding[H[i]];
		}
	cout << "translation_plane::HMO after embedding" << endl;
	cout << "Ge:" << endl;
	INT_matrix_print(Ge, q, q);
	cout << "He:" << endl;
	INT_matrix_print(He, q, q);

	GG = NEW_INT(q2 * q2);
	HH = NEW_INT(q2 * q2);
	omega = Sub->Basis[1];
	cout << "omega=" << omega << endl;
	for (alpha = 0; alpha < q2; alpha++) {
		for (beta = 0; beta < q2; beta++) {
			x = Sub->components[beta * 2 + 0];
			y = Sub->components[beta * 2 + 1];
			cout << "alpha=" << alpha << " beta=" << beta << " x=" << x << " y=" << y << endl;
			tmp1 = Ge[x * q + y];
			tmp2 = Fq2->negate(Fq2->mult(He[x * q + y], omega));
			f = Fq2->add(tmp1, tmp2);
			z = Fq2->frobenius_power(alpha, Fq2->e / 2);
			GG[alpha * q2 + beta] = f;
			HH[alpha * q2 + beta] = z;
			}
		}
	cout << "GG:" << endl;
	INT_matrix_print(GG, q2, q2);
	cout << "HH:" << endl;
	INT_matrix_print(HH, q2, q2);

	grassmann *Gq2;
	INT *Data2;
	INT Sz;

	Gq2 = new grassmann;
	Gq2->init(n, k, Fq2, verbose_level);

	Sz = q2 * q2 + 1;
	Data2 = NEW_INT(Sz);

	for (h = 0; h < Sz; h++) {
		for (i = 0; i < 8; i++) {
			M[i] = 0;
			}
		if (h == 1) {
			M[0 * 4 + 2] = 1;
			M[1 * 4 + 3] = 1;
			}
		else {
			if (h > 1) {
				h1 = h - 1;
				}
			else {
				h1 = 0;
				}
			M[0 * 4 + 0] = 1;
			M[1 * 4 + 1] = 1;
			y = h1 % q2;
			x = (h1 - y) / q2;
			cout << "h=" << h << " x=" << x << " y=" << y << endl;
			M[0 * 4 + 2] = x;
			M[0 * 4 + 3] = y;
			M[1 * 4 + 2] = GG[x * q2 + y];
			M[1 * 4 + 3] = HH[x * q2 + y];
			}
		cout << "element " << h << ":" << endl;
		INT_matrix_print(M, 2, 4);
		for (i = 0; i < 8; i++) {
			Gq2->M[i] = M[i];
			}
		Data2[h] = Gq2->rank_INT(0);
		cout << "has rank " << Data2[h] << endl;
		}

	BYTE fname2[1000];
	sprintf(fname2, "HMO_%s", fname);

	write_set_to_file(fname2, Data2, Sz, verbose_level);
	
	FREE_INT(Data2);
	delete Gq2;
	delete Fq2;
	delete Sub;
	FREE_INT(data);
	FREE_INT(G);
	FREE_INT(H);
	FREE_INT(Ge);
	FREE_INT(He);
	FREE_INT(GG);
	FREE_INT(HH);
}

void translation_plane::get_spread_matrices(INT *G, INT *H, INT *data, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT h, i, x, y, f, g;
	INT sz = order + 1;
	INT M[8];

	if (f_v) {
		cout << "translation_plane::get_spread_matrices" << endl;
		}
	for (i = 0; i < order; i++) {
		G[i] = -1;
		H[i] = -1;
		}
	for (h = 0; h < sz; h++) {
		Grass->unrank_INT(data[h], 0);
		for (i = 0; i < 8; i++) {
			M[i] = Grass->M[i];
			}
		//cout << "element " << h << ":" << endl;
		//INT_matrix_print(M, 2, 4);
		if (M[0 * 4 + 0] == 0 && 
			M[0 * 4 + 1] == 0 && 
			M[1 * 4 + 0] == 0 && 
			M[1 * 4 + 1] == 0) {
			continue;
			}
		if (M[0 * 4 + 0] != 1) {
			cout << "generator matrix is not in standard form" << endl;
			exit(1);
			}
		if (M[1 * 4 + 1] != 1) {
			cout << "generator matrix is not in standard form" << endl;
			exit(1);
			}
		if (M[0 * 4 + 1] != 0) {
			cout << "generator matrix is not in standard form" << endl;
			exit(1);
			}
		if (M[1 * 4 + 0] != 0) {
			cout << "generator matrix is not in standard form" << endl;
			exit(1);
			}
		x = M[0 * 4 + 2];
		y = M[0 * 4 + 3];
		f = M[1 * 4 + 2];
		g = M[1 * 4 + 3];
		G[x * q + y] = f;
		H[x * q + y] = g;
		}
	if (f_v) {
		cout << "translation_plane::get_FG_matrices" << endl;
		cout << "G:" << endl;
		INT_matrix_print(G, q, q);
		cout << "H:" << endl;
		INT_matrix_print(H, q, q);
		}
}

void translation_plane::print_spread(INT *data, INT sz)
{
	//INT sz = order + 1;
	INT h;

	for (h = 0; h < sz; h++) {
		Grass->unrank_INT(data[h], 0);
		cout << "Spread element " << h << ":" << endl;
		INT_matrix_print(Grass->M, k, n);
		}	
}

void translation_plane::report2(isomorph &Iso, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	BYTE fname[1000];
	INT target_size = order + 1;

	if (f_v) {
		cout << "translation_plane::report2" << endl;
		}
	sprintf(fname, "report_TP_%ld.tex", order);

	{
	ofstream f(fname);
	INT f_book = TRUE;
	INT f_title = TRUE;
	BYTE title[1000];
	const BYTE *author = "Anton Betten";
	INT f_toc = TRUE;
	INT f_landscape = FALSE;
	INT f_12pt = FALSE;
	INT f_enlarged_page = TRUE;
	INT f_pagenumbers = TRUE;

	sprintf(title, "Translation Planes of Order $%ld$", order);
	cout << "Writing file " << fname << " with " << Iso.Reps->count << " translation planes:" << endl;
	latex_head(f, f_book, f_title, 
		title, author, 
		f_toc, f_landscape, f_12pt, f_enlarged_page, f_pagenumbers);

	f << "\\chapter{Summary}" << endl << endl;
	f << "There are " << Iso.Reps->count << " Translation Planes." << endl << endl;


	//Iso.setup_and_open_solution_database(verbose_level - 1);

	INT i, first, c, id;
	INT u, v, h, rep, tt;
	longinteger_object go;
	INT data[1000];



	longinteger_object *Ago, *Ago_induced;
	INT *Ago_INT;

	Ago = new longinteger_object[Iso.Reps->count];
	Ago_induced = new longinteger_object[Iso.Reps->count];
	Ago_INT = NEW_INT(Iso.Reps->count);


	for (h = 0; h < Iso.Reps->count; h++) {
		rep = Iso.Reps->rep[h];
		first = Iso.orbit_fst[rep];
		c = Iso.starter_number[first];
		id = Iso.orbit_perm[first];		
		Iso.load_solution(id, data);

		sims *Stab;
		
		Stab = Iso.Reps->stab[h];

		Iso.Reps->stab[h]->group_order(Ago[h]);
		Ago_INT[h] = Ago[h].as_INT();
		//f << "Stabilizer has order $";
		//go.print_not_scientific(f);
		if (f_v) {
			cout << "translation_plane::print_isomorphism_types computing induced action on the set (in data)" << endl;
			}
		Iso.induced_action_on_set(Stab, data, 0 /*verbose_level*/);
		
			
		Iso.AA->group_order(Ago_induced[h]);
		}


	classify C_ago;

	C_ago.init(Ago_INT, Iso.Reps->count, FALSE, 0);
	cout << "Classification by ago:" << endl;
	C_ago.print(FALSE /*f_backwards*/);



	f << "\\chapter{Invariants}" << endl << endl;

	f << "Classification by automorphism group order: ";
	C_ago.print_naked_tex(f, FALSE /*f_backwards*/);
	//f << "$" << endl;
	f << "\\\\" << endl;

	f << "\\begin{center}" << endl;
	f << "\\begin{tabular}{|c|l|}" << endl;
	f << "\\hline" << endl;
	f << "Ago & Isom. Types \\\\" << endl;
	f << "\\hline" << endl;
	f << "\\hline" << endl;

	INT cnt, length, t, vv, *set;

	cnt = 0;
	for (u = C_ago.nb_types - 1; u >= 0; u--) {
		first = C_ago.type_first[u];
		length = C_ago.type_len[u];
		t = C_ago.data_sorted[first];

		f << t << " & ";

		set = NEW_INT(length);
		for (v = 0; v < length; v++, cnt++) {
			vv = first + v;
			i = C_ago.sorting_perm_inv[vv];
			set[v] = i;
			}

		INT_vec_heapsort(set, length);

		for (v = 0; v < length; v++, cnt++) {

			f << set[v];

			if (v < length - 1) {
				f << ",";
				if ((v + 1) % 10 == 0) {
					f << "\\\\" << endl;
					f << " & " << endl;
					}
				}
			}
		f << "\\\\" << endl;
		if (u > 0) {
			f << "\\hline" << endl;
			}
		FREE_INT(set);
		}
	f << "\\hline" << endl;
	f << "\\end{tabular}" << endl;
	f << "\\end{center}" << endl << endl;


	f << "\\clearpage" << endl << endl;

	f << "\\begin{center}" << endl;
	f << "\\begin{tabular}{|r|r|r|r|r|r|}" << endl;
	f << "\\hline" << endl;
	f << "ID & Isom. Type & $|\\mbox{Aut}|$ & $|\\mbox{Aut}|$ (induced) & \\# Orbits & Orbit Type\\\\" << endl;
	f << "\\hline" << endl;
	f << "\\hline" << endl;

	cnt = 0;
	for (u = 0; u < C_ago.nb_types; u ++) {
		first = C_ago.type_first[u];
		length = C_ago.type_len[u];
		t = C_ago.data_sorted[first];

		set = NEW_INT(length);
		for (v = 0; v < length; v++) {
			vv = first + v;
			i = C_ago.sorting_perm_inv[vv];
			set[v] = i;
			}

		INT_vec_heapsort(set, length);


		for (v = 0; v < length; v++) {
			vv = first + v;
			i = C_ago.sorting_perm_inv[vv];
			h = set[v];
			f << setw(3) << first + v + 1 << " & ";
			f << setw(3) << h << " & ";
			Ago[h].print_not_scientific(f);
			f << " & ";
			Ago_induced[h].print_not_scientific(f);

			orbit_info_short(f, Iso, h);


			f << "\\\\" << endl;
			cnt++;
			if ((cnt % 30) == 0) {
				f << "\\hline" << endl;
				f << "\\end{tabular}" << endl;
				f << "\\end{center}" << endl << endl;
				f << "\\begin{center}" << endl;
				f << "\\begin{tabular}{|r|r|r|r|r|r|}" << endl;
				f << "\\hline" << endl;
				f << "ID & Isom. Type & $|\\mbox{Aut}|$ & $|\\mbox{Aut}|$ (induced) & \\# Orbits & Orbit Type\\\\" << endl;
				f << "\\hline" << endl;
				f << "\\hline" << endl;
				}
			}
		FREE_INT(set);
		}

	f << "\\hline" << endl;
	f << "\\end{tabular}" << endl;
	f << "\\end{center}" << endl << endl;


	f << "\\chapter{The Translation Planes}" << endl << endl;

	f << "\\clearpage" << endl << endl;


	for (h = 0; h < Iso.Reps->count; h++) {
		rep = Iso.Reps->rep[h];
		first = Iso.orbit_fst[rep];
		c = Iso.starter_number[first];
		id = Iso.orbit_perm[first];		
		Iso.load_solution(id, data);


		f << "\\section{Isomorphism type " << h << "}" << endl;
		f << "\\bigskip" << endl;

		//f << "The ambient space has dimension " << Rk_of_span[h] << "\\\\" << endl;

		if (Iso.Reps->stab[h]) {
			Iso.Reps->stab[h]->group_order(go);
			f << "Stabilizer has order $";
			go.print_not_scientific(f);
			f << "$\\\\" << endl;
			}
		else {
			//cout << endl;
			}

#if 0
		if (h == 35) {
			cout << "Isomorphism type 35:" << endl;
			cout << "rep=" << rep << endl;
			cout << "first=" << first << endl;
			cout << "id=" << id << endl;
			cout << "starter_number=" << c << endl;
			cout << "solution:" << endl;
			INT_vec_print(cout, data, target_size);
			cout << endl;
			}
#endif

		sims *Stab;
		
		Stab = Iso.Reps->stab[h];

		if (f_v) {
			cout << "translation_plane::print_isomorphism_types computing induced action on the set (in data)" << endl;
			}
		Iso.induced_action_on_set(Stab, data, 0 /*verbose_level*/);
		
		longinteger_object go1;
			
		Iso.AA->group_order(go1);
		cout << "action " << Iso.AA->label << " computed, group order is " << go1 << endl;

		f << "Order of the group that is induced on the collection of subspaces is ";
		f << "$";
		go1.print_not_scientific(f);
		f << "$\\\\" << endl;
		

		schreier Orb;
		//longinteger_object go2;
		
		Iso.AA->compute_all_point_orbits(Orb, Stab->gens, verbose_level - 2);
		f << "With " << Orb.nb_orbits << " orbits on the subspaces\\\\" << endl;

		classify C_ol;

		C_ol.init(Orb.orbit_len, Orb.nb_orbits, FALSE, 0);

		f << "Orbit lengths: ";
		//INT_vec_print(f, Orb.orbit_len, Orb.nb_orbits);
		C_ol.print_naked_tex(f, FALSE /*f_backwards*/);
		f << " \\\\" << endl;

		f << "Orbits: ";
		Orb.list_all_orbits_tex(f);
		f << " \\\\" << endl;

	
		tt = (target_size + 3) / 4;

		f << "The subspaces by ranks:\\\\" << endl;
		f << "\\begin{center}" << endl;

		for (u = 0; u < 4; u++) {
			f << "\\begin{tabular}[t]{|c|c|}" << endl;
			f << "\\hline" << endl;
			f << "$i$ & Rank \\\\" << endl;
			f << "\\hline" << endl;
			for (i = 0; i < tt; i++) {
				v = u * tt + i;
				if (v < target_size) {
					f << "$" << v << "$ & $" << data[v] << "$ \\\\" << endl;
					}
				}
			f << "\\hline" << endl;
			f << "\\end{tabular}" << endl;
			}
		f << "\\end{center}" << endl; 

		f << "The subspaces:\\\\" << endl;
		for (i = 0; i < target_size; i++) {
			Grass->unrank_INT(data[i], 0/*verbose_level - 4*/);
			if ((i % 4) == 0) {
				if (i) {
					f << "$$" << endl;
					}
				f << "$$" << endl;
				}
			f << "\\left[" << endl;
			f << "\\begin{array}{c}" << endl;
			for (u = 0; u < k; u++) {
				for (v = 0; v < n; v++) {
					f << Grass->M[u * n + v];
					}
				f << "\\\\" << endl;
				}
			f << "\\end{array}" << endl;
			f << "\\right]" << endl;
			}
		f << "$$" << endl;


		report_stabilizer(Iso, f, h /* orbit */, 0 /* verbose_level */);

		if (k == 2) {
			klein(f, &Iso, h, Stab, Orb, data, Iso.size,  verbose_level);
			}

		f << "" << endl;
		f << "\\bigskip" << endl;
		f << "" << endl;
		f << "Induced action on the orbits:\\\\" << endl;
		f << "$$" << endl;
		f << "\\begin{array}{|c|c|c|c|}" << endl;
		f << "\\hline" << endl;
		f << "\\mbox{Orbit} & \\mbox{Length} & \\mbox{Induced} & \\mbox{Kernel} \\\\" << endl;
		f << "\\hline" << endl;
		for (i = 0; i < Orb.nb_orbits; i++) {
			INT fst, len, j;
			fst = Orb.orbit_first[i];
			len = Orb.orbit_len[i];

			cout << "inducing action on orbit " << i << " of length " << len << endl;
			f << i << " & " << len << " & ";
			INT *set;
			action *A1;
			longinteger_object go1, gok;

			set = NEW_INT(len);
			A1 = new action;
			for (j = 0; j < len; j++) {
				set[j] = data[Orb.orbit[fst + j]];
				}
			A1->induced_action_by_restriction(*Iso.A, TRUE, Stab, len, set, 0/*verbose_level*/);
			if (f_v) {
				cout << "after induced_action_by_restriction" << endl;
				}
			A1->group_order(go1);
			A1->Kernel->group_order(gok);
			cout << "induced group order " << go1 << " kernel order " << gok << endl;

			f << go1 << " & " << gok << "\\\\" << endl;

			FREE_INT(set);
			delete A1;
			}
		f << "\\hline" << endl;
		f << "\\end{array}" << endl;
		f << "$$" << endl;



		for (i = 0; i < Orb.nb_orbits; i++) {
			INT fst, len, j;
			fst = Orb.orbit_first[i];
			len = Orb.orbit_len[i];

			cout << "inducing action on orbit " << i << " of length " << len << endl;
			f << "Generators for the kernel in the action on orbit " << i << " are:";
			INT *set;
			action *A1;
			vector_ge *gens;
			INT *tl;
			longinteger_object go1, gok;

			set = NEW_INT(len);
			A1 = new action;
			gens = new vector_ge;
			tl = NEW_INT(Iso.A_base->base_len);
			for (j = 0; j < len; j++) {
				set[j] = data[Orb.orbit[fst + j]];
				}
			A1->induced_action_by_restriction(*Iso.A, TRUE, Stab, len, set, 0/*verbose_level*/);
			if (f_v) {
				cout << "after induced_action_by_restriction" << endl;
				}
			A1->group_order(go1);
			A1->Kernel->group_order(gok);
			cout << "induced group order " << go1 << " kernel order " << gok << endl;
			A1->Kernel->extract_strong_generators_in_order(*gens, tl, 0);

			if (gens->len == 0) {
				f << " No generators\\\\" << endl;
				}
			for (j = 0; j < gens->len; j++) {
		

				f << "$$ g_{" << j + 1 << "}=" << endl;
				A->element_print_latex(gens->ith(j), f);
				f << "$$" << endl;
				}
			
			FREE_INT(set);
			delete A1;
			delete gens;
			FREE_INT(tl);
			}


		}

	//Iso.close_solution_database(verbose_level - 1);

	BYTE prefix[1000];
	BYTE label_of_structure_plural[1000];

	sprintf(prefix, "TP_%ld_%ld", q, k);
	sprintf(label_of_structure_plural, "Translation Planes");
	isomorph_report_data_in_source_code_inside_tex(Iso, 
		prefix, label_of_structure_plural, f, verbose_level);



	latex_foot(f);
	
	FREE_INT(Ago_INT);
	delete [] Ago;
	delete [] Ago_induced;
	}

	cout << "Written file " << fname << " of size " << file_size(fname) << endl;

}

void translation_plane::all_cooperstein_thas_quotients(isomorph &Iso, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT h;
	BYTE fname[1000];
	INT cnt = 0;

	if (f_v) {
		cout << "translation_plane::all_cooperstein_thas_quotients" << endl;
		}


	//Iso.setup_and_open_solution_database(verbose_level - 1);


	sprintf(fname, "quotients_q%ld.txt", order);
	{
	ofstream f(fname);


	for (h = 0; h < Iso.Reps->count; h++) {

		cooperstein_thas_quotients(Iso, f, h, cnt, verbose_level - 1);
		
		}


	f << -1 << endl;
	}
	cout << "Written file " << fname << " of size " << file_size(fname) << endl;


	//Iso.close_solution_database(verbose_level - 1);

	if (f_v) {
		cout << "translation_plane::all_cooperstein_thas_quotients done" << endl;
		}
}



void translation_plane::cooperstein_thas_quotients(isomorph &Iso, ofstream &f, INT h, INT &cnt, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT rep, first, c, id;
	sims *Stab;
	INT data[1000];
	INT data2[1000];
	INT u, fst, orbit_length, a, i, idx, i0, j, the_point, pivot, b, rem;
	INT *Mtx;
	INT *vec1;
	INT *vec2;
	INT **Pts;
	INT nb_points;
	INT *List;
	grassmann *Gr;
	longinteger_domain Dom;



	if (f_v ) {
		cout << "translation_plane::cooperstein_thas_quotients" << endl;
		cout << "translation_plane::cooperstein_thas_quotients h=" << h << endl;
		}

	rep = Iso.Reps->rep[h];
	first = Iso.orbit_fst[rep];
	c = Iso.starter_number[first];
	id = Iso.orbit_perm[first];		
	Iso.load_solution(id, data);


	Stab = Iso.Reps->stab[h];

	schreier Orb;
	longinteger_object go;
	longinteger_object stab_order;
		
	Stab->group_order(go);

	if (f_v) {
		cout << "translation_plane::cooperstein_thas_quotients Isomorphism type " << h << " with automorphism group of order " << go << ":" << endl;
		}

	if (f_vv) {
		cout << "translation_plane::cooperstein_thas_quotients before compute_all_point_orbits" << endl;
		}

	Iso.A_base->compute_all_point_orbits(Orb, Stab->gens, 0 /*verbose_level - 2*/);

	if (f_vv) {
		cout << "translation_plane::cooperstein_thas_quotients There are " << Orb.nb_orbits << " orbits on points" << endl;
		}


	
	Mtx = NEW_INT(k * n);
	vec1 = NEW_INT(n);
	vec2 = NEW_INT(n);
	Pts = NEW_PINT(order + 1);
	List = NEW_INT(order);
	Gr = new grassmann;

	Gr->init(n - 1, k, F, 0 /* verbose_level */);
	for (i = 0; i < order + 1; i++) {
		Grass->unrank_INT_here(Mtx, data[i], 0/*verbose_level - 4*/);
		all_PG_elements_in_subspace(F, Mtx, k, n, Pts[i], nb_points, 0 /* verbose_level */);
		INT_vec_heapsort(Pts[i], nb_points);
		}

	for (u = 0; u < Orb.nb_orbits; u++) {
		fst = Orb.orbit_first[u];
		orbit_length = Orb.orbit_len[u];
		
		the_point = Orb.orbit[fst];
		Dom.integral_division_by_INT(go, orbit_length, stab_order, rem);

		if (f_vv) {
			cout << "translation_plane::cooperstein_thas_quotients Orbit " << u << " is represented by point " << the_point << " orbit lnegth = " << orbit_length << " stabilizer order before " << go << " after " << stab_order << endl;
			}


		PG_element_unrank_modified(*F, vec1, 1, n, the_point);
		PG_element_normalize_from_front(*F, vec1, 1, n);
		pivot = INT_vec_find_first_nonzero_entry(vec1, n);
			// GALOIS/util.C

		for (i = 0; i < order + 1; i++) {
			if (INT_vec_search(Pts[i], nb_points, the_point, idx)) {
				break;
				}
			}
		if (i == order + 1) {
			cout << "translation_plane::cooperstein_thas_quotients Did not find the point" << endl;
			exit(1);
			}
		i0 = i;
		j = 0;
		for (i = 0; i < order + 1; i++) {
			if (i != i0) {
				List[j++] = i;
				}
			}
		if (j != order) {
			cout << "translation_plane::cooperstein_thas_quotients j != order" << endl;
			exit(1);
			}
		for (i = 0; i < order; i++) {
			a = data[List[i]];
			Grass->unrank_INT_here(Mtx, a, 0/*verbose_level - 4*/);
			INT_vec_copy(vec1, vec2, n);
			for (j = 0; j < k; j++) {
				F->Gauss_step(vec2, Mtx + j * n, n, pivot, 0 /* verbose_level*/);
					// afterwards: v2[idx] = 0 and v1,v2 span the same space as before
					// v1 is not changed if v1[idx] is nonzero
				}

#if 1
			// delete column 'pivot' in the k x n matrix Mtx.
			// Afterwards, the matrix is k x (n - 1)

			INT_matrix_delete_column_in_place(Mtx, k, n, pivot);
				// GALOIS/util.C
#endif

			if (f_vv) {
				cout << "translation_plane::cooperstein_thas_quotients the reduction of the " << i << "-th matrix is:" << endl;
				INT_matrix_print(Mtx, k, n - 1);
				}

			b = Gr->rank_INT_here(Mtx, 0/*verbose_level - 4*/);
			data2[i] = b;
			}

		if (f_vv) {
			cout << "translation_plane::cooperstein_thas_quotients The quotient system with respect to orbit " << u << " / " << Orb.nb_orbits << " is:" << endl;
			INT_vec_print(cout, data2, order);
			cout << endl;
			}


		f << h << " " << u << " " << the_point << " " << orbit_length << " ";
		go.print_not_scientific(f);
		f << " ";
		stab_order.print_not_scientific(f);
		f << " ";
		for (i = 0; i < order; i++) {
			f << " " << data2[i];
			}
		f << endl;



		BYTE fname[1000];
		sprintf(fname, "quotient_q%ld_iso%ld_nb%ld_orbit_length%ld.txt", i_power_j(q, k), h, u, orbit_length);
		write_set_to_file(fname, data2, order, 0 /* verbose_level*/);
		cnt++;


		} // next u

	FREE_INT(Mtx);
	FREE_INT(vec1);
	FREE_INT(vec2);
	for (i = 0; i < order + 1; i++) {
		FREE_INT(Pts[i]);
		}
	FREE_PINT(Pts);
	FREE_INT(List);
	delete Gr;
	if (f_v ) {
		cout << "translation_plane::cooperstein_thas_quotients done" << endl;
		}
}

void translation_plane::orbit_info_short(ofstream &f, isomorph &Iso, INT h)
{
	INT rep, first, c, id;

	sims *Stab;
		
	INT data[1000];

	rep = Iso.Reps->rep[h];
	first = Iso.orbit_fst[rep];
	c = Iso.starter_number[first];
	id = Iso.orbit_perm[first];		
	Iso.load_solution(id, data);


	Stab = Iso.Reps->stab[h];

	Iso.induced_action_on_set(Stab, data, 0 /*verbose_level*/);
		
	longinteger_object go1;
			
	Iso.AA->group_order(go1);
	cout << "action " << Iso.AA->label << " computed, group order is " << go1 << endl;


#if 0
	f << "Order of the group that is induced on the collection of subspaces is ";
	f << "$";
	go1.print_not_scientific(f);
	f << "$\\\\" << endl;
#endif	

	schreier Orb;
	//longinteger_object go2;
		
	Iso.AA->compute_all_point_orbits(Orb, Stab->gens, 0 /*verbose_level - 2*/);
	//f << "With " << Orb.nb_orbits << " orbits on the subspaces\\\\" << endl;

	f << " & " << Orb.nb_orbits << " & ";

	classify C_ol;

	C_ol.init(Orb.orbit_len, Orb.nb_orbits, FALSE, 0);

	//f << "Orbit lengths: ";
	//INT_vec_print(f, Orb.orbit_len, Orb.nb_orbits);
	C_ol.print_naked_tex(f, FALSE /*f_backwards*/);
	//f << " \\\\" << endl;
	
}



void translation_plane::report_stabilizer(isomorph &Iso, ofstream &f, INT orbit, INT verbose_level)
{
	sims *Stab;
	longinteger_object go;
	INT i;

	Stab = Iso.Reps->stab[orbit];
	Stab->group_order(go);

	f << "The stabilizer of order $" << go << "$ is generated by:\\\\" << endl;
	for (i = 0; i < Stab->gens.len; i++) {
		
		INT *fp, n, ord;
		
		fp = NEW_INT(A->degree);
		n = A->find_fixed_points(Stab->gens.ith(i), fp, 0);
		//cout << "with " << n << " fixed points" << endl;
		FREE_INT(fp);

		ord = A->element_order(Stab->gens.ith(i));

		f << "$$ g_{" << i + 1 << "}=" << endl;
		A->element_print_latex(Stab->gens.ith(i), f);
		f << "$$" << endl << "of order $" << ord << "$ and with " << n << " fixed points" << endl;
		}
}



// ####################################################################################
// global functions:
// ####################################################################################



void translation_plane_early_test_func_callback(INT *S, INT len, 
	INT *candidates, INT nb_candidates, 
	INT *good_candidates, INT &nb_good_candidates, 
	void *data, INT verbose_level)
{
	translation_plane *T = (translation_plane *) data;
	INT f_v = (verbose_level >= 1);
	
	if (f_v) {
		cout << "early_test_func for set ";
		print_set(cout, len, S);
		cout << endl;
		}
	T->early_test_func(S, len, 
		candidates, nb_candidates, 
		good_candidates, nb_good_candidates, 
		verbose_level - 2);
	if (f_v) {
		cout << "early_test_func done" << endl;
		}
}

INT translation_plane_check_function_callback(INT len, INT *S, void *data, INT verbose_level)
{
	translation_plane *T = (translation_plane *) data;
	INT f_OK;
	
	f_OK = T->check_function(len, S, verbose_level);
	return f_OK;
}

INT translation_plane_check_function_incremental_callback(INT len, INT *S, void *data, INT verbose_level)
{
	translation_plane *T = (translation_plane *) data;
	INT f_OK;
	
	f_OK = T->check_function_incremental(len, S, verbose_level);
	return f_OK; 
}

INT translation_plane_check_conditions(INT len, INT *S, void *data, INT verbose_level)
{
	translation_plane *T = (translation_plane *) data;
	return T->check_function(len, S, verbose_level);
}

void translation_plane_callback_report(isomorph *Iso, void *data, INT verbose_level)
{
	translation_plane *T = (translation_plane *) data;
	
	T->report2(*Iso, verbose_level);
}

void translation_plane_callback_make_quotients(isomorph *Iso, void *data, INT verbose_level)
{
	translation_plane *T = (translation_plane *) data;
	
	T->all_cooperstein_thas_quotients(*Iso, verbose_level);
}


