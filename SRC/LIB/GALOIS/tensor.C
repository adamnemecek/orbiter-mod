// tensor.C
//
// Anton Betten
//
// moved here:  Dec 25 2008




#include "galois.h"




void twisted_tensor_product_codes(
	INT *&H_subfield, INT &m, INT &n, 
	finite_field *F, finite_field *f,
	INT f_construction_A, INT f_hyperoval, 
	INT f_construction_B, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT index;
	INT exponents[9];
	INT *M;
	//INT *H_subfield;
	INT *C;
	INT *C_inv;

	INT q = f->q;
	INT q2;
	INT Q;
	//INT m, n;
	INT r;
	INT beta, beta_q;
	INT f_elements_exponential = TRUE;
	const BYTE *symbol_for_print = "\\alpha";
	const BYTE *symbol_for_print_subfield = "\\omega";
	
	
	
	if (f_v) {
		cout << "twisted_tensor_product_codes" << endl;
		cout << "f_construction_A=" << f_construction_A << endl;
		cout << "f_hyperoval=" << f_hyperoval << endl;
		cout << "f_construction_B=" << f_construction_B << endl;
		}
	

	q2 = q * q;
	Q = 0;
	if (f_construction_A) {
		Q = q2;
		}
	else if (f_construction_B) {
		Q = q2 * q;
		}
	index = (Q - 1) / (q - 1);

	if (Q != F->q) {
		cout << "twisted_tensor_product_codes Q != F->q" << endl;
		exit(1);
		}
	

	if (f_vv) {
		cout << "q = " << q << endl;
		cout << "Q = " << Q << endl;
		cout << "index = " << index << endl;
		}

#if 0
	F.init_override_polynomial(Q, override_poly_Q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << Q << " initialized" << endl;
		}

	f.init_override_polynomial(q, override_poly_q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << q << " initialized" << endl;
		cout << "index = " << index << endl;
		}
#endif
	
	F->compute_subfields(verbose_level - 2);


	create_matrix_M(
			M, 
			F, f,
			m, n, beta, r, exponents, 
			f_construction_A, f_hyperoval, f_construction_B, 
			f_elements_exponential, symbol_for_print, 
			verbose_level - 2);

	beta_q = F->power(beta, q);

	if (f_vv) {
		cout << "twisted_tensor_product_codes after create_matrix_M" << endl;
		cout << "m = " << m << endl;
		cout << "n = " << n << endl;
		cout << "Q = " << Q << endl;
		cout << "q2 = " << q2 << endl;
		cout << "beta = " << beta << endl;
		cout << "beta_q = " << beta_q << endl;
		cout << "Exponents: ";
		INT_vec_print(cout, exponents, m);
		cout << endl;
		}

	if (f_vv) {
		cout << "twisted_tensor_product_codes: M:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);

		F->latex_matrix(cout, f_elements_exponential, symbol_for_print, M, m, n);
		}

	


#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif




	C = NEW_INT(m * m);
	C_inv = NEW_INT(m * m);
	H_subfield = NEW_INT(m * n);


	create_matrix_H_subfield(F, f, 
		H_subfield, C, C_inv, M, m, n, beta, beta_q, 
		f_elements_exponential, symbol_for_print, symbol_for_print_subfield, 
		f_construction_A, f_hyperoval, f_construction_B, 
		verbose_level - 2);

		
	if (f_v) {
		cout << "twisted_tensor_product_codes: after create_matrix_H_subfield" << endl;
		cout << "H_subfield:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		f->latex_matrix(cout, f_elements_exponential, symbol_for_print_subfield, H_subfield, m, n);
		}

	FREE_INT(M);
	FREE_INT(C);
	FREE_INT(C_inv);

}


void create_matrix_M(
	INT *&M, 
	finite_field *F, finite_field *f,
	INT &m, INT &n, INT &beta, INT &r, INT *exponents, 
	INT f_construction_A, INT f_hyperoval, INT f_construction_B, 
	INT f_elements_exponential, const BYTE *symbol_for_print, 
	INT verbose_level)
// INT exponents[9]
{
	INT f_v = (verbose_level >= 1);
	//INT f_vv = (verbose_level >= 2);
	INT i, j, t, q, Q, q2;

	q = f->q;
	q2 = q * q;

	
	if (f_construction_A) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = "";
		//q = 3; override_poly_Q = ""; override_poly = "";
		q = 4; override_poly_Q = "19"; override_poly = "7";
			// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
			// F_16 generated by X^4+X+1 = 19
			// F_4 generated by X^2+X+1 = 7
		//q = 5; override_poly_Q = "47"; override_poly = "";
			// F_625  generated by X^4 + X^3 + 3X + 2
			// F_25  generated by X^2 + 4X + 2  = 47
		//q = 7; override_poly_Q = ""; override_poly = "";
		//q = 8; override_poly_Q = "97"; override_poly = "11";
			// F_4096 generated by x^12+x^6+x^4+x+1 
			// F_64 generated by X^6+X^5+1 = 97
			// F_8 generated by X^3+X+1 = 11
		//q = 9; override_poly_Q = ""; override_poly = "17";
#endif
		Q = q2;
		beta = q;
		m = 9;
		if (f_hyperoval) {
			n = Q + 2;
			}
		else {
			n = Q + 1;
			}
		r = 5;
		if (q == 4)
			r = 7;
		if (q == 3)
			r = 9;
		// 3 orbits of length 1: 0, q+1, 2q+2
		exponents[0] = 0;
		exponents[1] = q + 1;
		exponents[2] = 2 * q + 2;
		//orbit (q,1)
		exponents[3] = q;
		exponents[4] = 1;
		// orbit (2q, 2)
		exponents[5] = 2 * q;
		exponents[6] = 2;
		// orbit (2q+1, q+2)
		exponents[7] = 2 * q + 1;
		exponents[8] = q + 2;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 2 * q;
		//exponents[3] = 1;
		//exponents[4] = q + 1;
		//exponents[5] = 2 * q + 1;
		//exponents[6] = 2;
		//exponents[7] = q + 2;
		//exponents[8] = 2 * q + 2;
		}
	else if (f_construction_B) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = ""; r = 9;
		//q = 3; override_poly_Q = ""; override_poly = ""; r = 5;
		q = 4; override_poly_Q = ""; override_poly = "7"; r = 4;
			// F_4096  generated by X^8 + X^4 + X^3 + X^2 + 1 = 4096
		//q = 5; override_poly_Q = ""; override_poly = ""; r = 4;
		//q = 7; override_poly_Q = ""; override_poly = ""; r = 4;
#endif

		beta = q;
		Q = q2 * q;
		m = 8;
		n = Q + 1;
	
		exponents[0] = 0;
		exponents[1] = q2 + q + 1;
		exponents[2] = 1;
		exponents[3] = q;
		exponents[4] = q2;
		exponents[5] = q + 1;
		exponents[6] = q2 + q;
		exponents[7] = q2 + 1;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 1;
		//exponents[3] = q + 1;
		//exponents[4] = q2;
		//exponents[5] = q2 + q;
		//exponents[6] = q2 + 1;
		//exponents[7] = q2 + q + 1;
		}
	else {
		cout << "create_matrix_M(): please specify the construction using option -A or -B" << endl;
		exit(1);
		}


	// create matrix M:
	M = NEW_INT(m * n);
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
			}
		}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = F->power(t, exponents[i]);
			}
		}
	if (f_construction_A) {
		M[2 * n + Q] = 1;
		if (f_hyperoval)
			M[1 * n + Q + 1] = 1;
		}
	else if (f_construction_B) {
		M[1 * n + Q] = 1;
		}

	if (f_v) {
		cout << "M:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);

		F->latex_matrix(cout, f_elements_exponential, symbol_for_print, M, m, n);
		}


	if (f_v) {
		INT *all_one, *col_sum;
		
		all_one = NEW_INT(n);
		col_sum = NEW_INT(m);
		for (i = 0; i < n; i++)
			all_one[i] = 1;
		F->mult_matrix_matrix(M, all_one, col_sum, m, n, 1);
		cout << "overall col_sum:" << endl;
		print_integer_matrix_width(cout, col_sum, m, 1, 1, 2);
		FREE_INT(all_one);
		FREE_INT(col_sum);
		}


}



void create_matrix_H_subfield(finite_field *F, finite_field*f, 
	INT *H_subfield, INT *C, INT *C_inv, INT *M, INT m, INT n, INT beta, INT beta_q, 
	INT f_elements_exponential, const BYTE *symbol_for_print, const BYTE *symbol_for_print_subfield, 
	INT f_construction_A, INT f_hyperoval, INT f_construction_B, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT i, j;
	INT q;
	//INT *C;
	//INT *C_inv;
	INT *H;
	INT *AA;

	q = f->q;
	
	// matrix C is zero:
	H = NEW_INT(m * n);
	AA = NEW_INT(m * m);
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
			}
		}


	if (f_construction_A) {
		INT nb_C_coeffs = 15;
		INT k, aa;
		INT C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			3, 3, 1,
			3, 4, 1,
			4, 3, beta_q,
			4, 4, beta,
			5, 5, 1,
			5, 6, 1,
			6, 5, beta_q,
			6, 6, beta,
			7, 7, 1,
			7, 8, 1,
			8, 7, beta_q,
			8, 8, beta,
			};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
			}
		}
	else if (f_construction_B) {
		INT nb_C_coeffs = 20;
		INT k, aa;
		INT C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			2, 3, 1,
			2, 4, 1,
			3, 2, beta,
			3, 3, beta_q,
			3, 4, F->beta_trinomial(q, beta, 1, 0, 0), 
			4, 2, F->beta_trinomial(q, beta, 0, 0, 2),
			4, 3, F->beta_trinomial(q, beta, 0, 2, 0), 
			4, 4, F->beta_trinomial(q, beta, 2, 0, 0), 
			5, 5, 1,
			5, 6, 1,
			5, 7, 1,
			6, 5, F->beta_trinomial(q, beta, 0, 1, 1),
			6, 6, F->beta_trinomial(q, beta, 1, 1, 0),
			6, 7, F->beta_trinomial(q, beta, 1, 0, 1),
			7, 5, F->beta_trinomial(q, beta, 0, 2, 2),
			7, 6, F->beta_trinomial(q, beta, 2, 2, 0),
			7, 7, F->beta_trinomial(q, beta, 2, 0, 2),
			};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
			}
		}

	
	if (f_v) {
		cout << "matrix C:" << endl;
		print_integer_matrix_width(cout, C, m, m, m, 2);
		F->latex_matrix(cout, f_elements_exponential, symbol_for_print, C, m, m);
		}


	F->invert_matrix(C, C_inv, m);
	
	if (f_vv) {
		cout << "C_inv:" << endl;
		print_integer_matrix_width(cout, C_inv, m, m, m, 2);
		}

	F->mult_matrix_matrix(C, C_inv, AA, m, m, m);

	if (f_vv) {
		cout << "C * C_inv:" << endl;
		print_integer_matrix_width(cout, AA, m, m, m, 2);
		}
	

	F->mult_matrix_matrix(C, M, H, m, m, n);

	if (f_v) {
		cout << "H = C * M:" << endl;
		print_integer_matrix_width(cout, H, m, n, n, 2);
		F->latex_matrix(cout, f_elements_exponential, symbol_for_print, H, m, n);
		}
	
	
#if 0
	rk = F.Gauss_INT(M, FALSE /* f_special */, TRUE /* f_complete */, base_cols, 
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */, 
		verbose_level - 2);
	cout << "has rank " << rk << endl;
#endif

	tt_field_reduction(*F, *f, m, n, H, H_subfield, verbose_level - 2);

	if (f_v) {
		cout << "H_subfield:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		f->latex_matrix(cout, f_elements_exponential, symbol_for_print_subfield, H_subfield, m, n);
		}
	
	FREE_INT(H);
	FREE_INT(AA);
}



void tt_field_reduction(finite_field &F, finite_field &f, INT m, INT n, INT *M, INT *MM, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT  i, j, a, z, b, c, Q, q;
	INT index;
	
	Q = F.q;
	q = f.q;
	index = (Q - 1) / (q - 1);
	if (f_v) {
		cout << "field reduction, Q=" << Q << " q=" << q << " index=" << index << endl;
		}
	if (f_vv) {
		cout << "before:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);
		//print_integer_matrix(cout, M, m, n);
		cout << endl;
		F.print_integer_matrix_zech(cout, M, m, n);
		cout << endl;
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			a = M[i * n + j];
			if (a == 0) {
				c = 0;
				}
			else {
				if (f.e == 1) {
					if (a >= q) {
						cout << "field reduction: element does not lie in the subfield: " << a << endl;
						exit(1);
						}
					c = a;
					}
				else {
					z = F.log_alpha(a);
					b = z / index;
					if (b * index != z) {
						cout << "b * index != z" << endl;
						exit(1);
						}
					c = f.alpha_power(b);
					}
				}
			MM[i * n + j] = c;
			}
		}
	if (f_vv) {
		cout << "after:" << endl;
		print_integer_matrix_width(cout, MM, m, n, n, 2);
		//print_integer_matrix(cout, MM, m, n);
		cout << endl;
		f.print_integer_matrix_zech(cout, MM, m, n);
		cout << endl;
		}
}





//############################################### old stuff:

void make_tensor_code_9dimensional_as_point_set(finite_field *F, 
	INT *&the_set, INT &length, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_hyperoval = FALSE;
	const BYTE *override_poly = "";
	const BYTE *override_poly_Q = "";
	INT i, t, q;
	INT *code;
	
	if (f_v) {
		cout << "make_tensor_code_9dimensional_as_point_set" << endl;
		}
	q = F->q;
	if (q == 2) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 3) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 4) {
		override_poly_Q = "19"; override_poly = "7"; f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
		}
	else if (q == 5) {
		override_poly_Q = "47"; override_poly = ""; f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
		}
	else if (q == 7) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 8) {
		override_poly_Q = "97"; override_poly = "11"; f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1 
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
		}
	else if (q == 9) {
		override_poly_Q = ""; override_poly = "17"; f_hyperoval = FALSE;
		}
	make_tensor_code_9_dimensional(q, override_poly_Q, override_poly, 
		f_hyperoval, code, length, verbose_level - 1);
	
	the_set = NEW_INT(length);
	
	INT pt[9], rk;
	
	for (t = 0; t < length; t++) {
		for (i = 0; i < 9; i++) {
			pt[i] = code[i * length + t];
			}
		PG_element_rank_modified(*F, pt, 1, 9, rk);
		the_set[t] = rk;
		}
	FREE_INT(code);
	if (f_v) {
		cout << "make_tensor_code_9dimensional_as_point_set done" << endl;
		cout << "created the set: ";
		INT_vec_print(cout, the_set, length);
		cout << endl;
		}
}

void make_tensor_code_9_dimensional(INT q, 
	const BYTE *override_poly_Q, const BYTE *override_poly, 
	INT f_hyperoval, 
	INT *&code, INT &length, 
	INT verbose_level)
{
	finite_field F;
	finite_field f;
	rank_checker rc;
	INT exponents[9];
	INT *M;
	INT *C;
	INT *C_inv;
	INT *H;
	INT *H_subfield;
	INT index, Q, i, j, t, m, n, r, beta, beta_q;
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	
	
	if (f_v) {
		cout << "make_tensor_code_9_dimensional q=" << q << endl;
		}
	
	//q = 2; override_poly_Q = ""; override_poly = ""; INT f_hyperoval = FALSE;
	//q = 3; override_poly_Q = ""; override_poly = ""; INT f_hyperoval = FALSE;
	//q = 4; override_poly_Q = "19"; override_poly = "7"; INT f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
	//q = 5; override_poly_Q = "47"; override_poly = ""; INT f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
	//q = 7; override_poly_Q = ""; override_poly = ""; INT f_hyperoval = FALSE;
	//q = 8; override_poly_Q = "97"; override_poly = "11"; INT f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1 
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
	//q = 9; override_poly_Q = ""; override_poly = "17"; INT f_hyperoval = FALSE;
	beta = q;
	Q = q * q;
	m = 9;
	if (f_hyperoval) {
		n = Q + 2;
		}
	else {
		n = Q + 1;
		}
	r = 5;
	if (q == 4)
		r = 7;
	if (q == 3)
		r = 9;
	exponents[0] = 0;
	exponents[1] = q + 1;
	exponents[2] = 2 * q + 2;
	exponents[3] = q;
	exponents[4] = 1;
	exponents[5] = 2 * q;
	exponents[6] = 2;
	exponents[7] = 2 * q + 1;
	exponents[8] = q + 2;
	//exponents[0] = 0;
	//exponents[1] = q;
	//exponents[2] = 2 * q;
	//exponents[3] = 1;
	//exponents[4] = q + 1;
	//exponents[5] = 2 * q + 1;
	//exponents[6] = 2;
	//exponents[7] = q + 2;
	//exponents[8] = 2 * q + 2;

	index = (Q - 1) / (q - 1);
	

	cout << "q = " << q << " override polynomial = " << override_poly << endl;
	cout << "Q = " << Q << endl;

	F.init_override_polynomial(Q, override_poly_Q, verbose_level);
	cout << "field of order " << Q << " initialized" << endl;
	beta_q = F.power(beta, q);
	f.init_override_polynomial(q, override_poly, verbose_level);
	cout << "field of order " << q << " initialized" << endl;
	cout << "n = " << n << endl;
	cout << "index = " << index << endl;
	cout << "beta = " << beta << endl;
	cout << "beta_q = " << beta_q << endl;
	F.compute_subfields(verbose_level - 3);
	
	M = NEW_INT(m * n);
	C = NEW_INT(m * m);
	C_inv = NEW_INT(m * m);
	H = NEW_INT(m * n);
	H_subfield = NEW_INT(m * n);

	rc.init(&f, m, n, r + 1);

	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
			}
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
			}
		}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = F.power(t, exponents[i]);
			}
		}
	{
	M[2 * n + Q] = 1;
	if (f_hyperoval)
		M[1 * n + Q + 1] = 1;
	INT nb_C_coeffs = 15;
	INT k, aa;
	INT C_coeffs[] = {
		0, 0, 1,
		1, 1, 1,
		2, 2, 1,
		3, 3, 1,
		3, 4, 1,
		4, 3, beta_q,
		4, 4, beta,
		5, 5, 1,
		5, 6, 1,
		6, 5, beta_q,
		6, 6, beta,
		7, 7, 1,
		7, 8, 1,
		8, 7, beta_q,
		8, 8, beta,
		};
	for (k = 0; k < nb_C_coeffs; k++) {
		i = C_coeffs[k * 3 + 0];
		j = C_coeffs[k * 3 + 1];
		aa = C_coeffs[k * 3 + 2];
		C[i * m + j] = aa;
		}
	}
		
	cout << "M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
	
	{
		INT *all_one, *col_sum;
		
		all_one = NEW_INT(n);
		col_sum = NEW_INT(m);
		for (i = 0; i < n; i++)
			all_one[i] = 1;
		F.mult_matrix_matrix(M, all_one, col_sum, m, n, 1);
		cout << "col_sum:" << endl;
		print_integer_matrix_width(cout, col_sum, m, 1, 1, 2);
		FREE_INT(all_one);
		FREE_INT(col_sum);
	}
	
#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif
	
	
	cout << "C:" << endl;
	print_integer_matrix_width(cout, C, m, m, m, 2);

	F.invert_matrix(C, C_inv, m);
	
	cout << "C_inv:" << endl;
	print_integer_matrix_width(cout, C_inv, m, m, m, 2);

	{
	INT *AA;
	AA = NEW_INT(m * m);
	F.mult_matrix_matrix(C, C_inv, AA, m, m, m);
	cout << "C * C_inv:" << endl;
	print_integer_matrix_width(cout, AA, m, m, m, 2);
	FREE_INT(AA);
	}

	F.mult_matrix_matrix(C, M, H, m, m, n);
	cout << "H = C * M:" << endl;
	print_integer_matrix_width(cout, H, m, n, n, 2);
	
	
#if 0
	rk = F.Gauss_INT(M, FALSE /* f_special */, TRUE /* f_complete */, base_cols, 
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */, 
		FALSE, FALSE);
	cout << "has rank " << rk << endl;
#endif

	if (f_vv) {
		cout << "before field reduction:" << endl;
		print_integer_matrix_width(cout, H, m, n, n, 2);
		cout << endl;
		f.print_integer_matrix_zech(cout, H, m, n);
		cout << endl;
		}
	F.retract_INT_vec(f, 2, H, H_subfield, m * n, 0 /* verbose_level */);
	//field_reduction(F, f, m, n, H, H_subfield, TRUE, TRUE);
	if (f_vv) {
		cout << "after field reduction:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		cout << endl;
		f.print_integer_matrix_zech(cout, H_subfield, m, n);
		cout << endl;
		}
	cout << "H_subfield:" << endl;
	print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
	
	code = H_subfield;
	length = n;

	FREE_INT(M);
	FREE_INT(C);
	FREE_INT(C_inv);
	FREE_INT(H);
	
}

