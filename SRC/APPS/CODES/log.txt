codes.C version 5/18/2009
-n 7
-k 4
-q 2
-d 1
n=7
k=4
q=2
d=1
code_generator::init
code_generator::init calling init_matrix_group
action::init_projective_group
n=3 q=2
f_semilinear=0
f_basis=1
action::init_projective_group before M->init_projective_group
matrix_group::init_projective_group
n=3
q=2
f_semilinear=0
matrix_group::compute_elt_size
bits_per_digit = 1
bits_extension_degree = 0
bits_per_elt = 9
char_per_elt = 2
elt_size_INT_half = 9
elt_size_INT = 18
matrix_group::compute_elt_size done
matrix_group::init_projective_group elt_size_INT = 18
matrix_group::allocate_data
matrix_group::allocate_data done
matrix_group::setup_page_storage
matrix_group::setup_page_storage calling Elts->init()
page_storage::init, verbose_level=14
warning: raising entry_size to sizeof(INT) = 8
page_storage::entry_size=8
(INT)sizeof(INT)=8
page_length_log = 20
page_length = 1048576
page_size = 8388608
page_storage::init page_size too big
the maximum page size in BYTE is 5242880
page_storage::entry_size=8
(INT)sizeof(INT)=8
page_length_log = 19
page_length = 524288
page_size = 4194304
page_size is OK
allocation_table_length=65537
allocating pages / allocation_tables
allocating page[0] of size 4194304
allocating allocation_tables[0] of size 65537
pages[0]/allocation_tables[0] allocated
matrix_group::setup_page_storage calling GL_one()
matrix_group::setup_page_storage calling Elts->store()
identity element stored, hdl = 0
matrix_group::setup_page_storage done
matrix_group::init_projective_group before init_base
matrix_group::init_base
matrix_group::init_base before init_base_projective
matrix_group::init_base_projective verbose_level=14
matrix_group::init_base_projective degree=7
matrix_group_base_len_projective_group: n=3 q=2 f_semilinear=0 base_len = 3
matrix_group::init_base_projective base_len=3
matrix_group::init_base_projective before projective_matrix_group_base_and_orbits
projective_matrix_group_base_and_orbits
projective_matrix_group_base_and_orbits transversal 0 of length 7
projective_matrix_group_base_and_orbits before PG_element_modified_not_in_subspace_perm
projective_matrix_group_base_and_orbits after PG_element_modified_not_in_subspace_perm
projective_matrix_group_base_and_orbits transversal 1 of length 6
projective_matrix_group_base_and_orbits before PG_element_modified_not_in_subspace_perm
projective_matrix_group_base_and_orbits after PG_element_modified_not_in_subspace_perm
projective_matrix_group_base_and_orbits transversal 2 of length 4
projective_matrix_group_base_and_orbits before PG_element_modified_not_in_subspace_perm
projective_matrix_group_base_and_orbits after PG_element_modified_not_in_subspace_perm
projective_matrix_group_base_and_orbits base: ( 0, 1, 2 )
projective_matrix_group_base_and_orbits transversal_length: ( 7, 6, 4 )
projective_matrix_group_base_and_orbits done
matrix_group::init_base_projective: finished
matrix_group::init_base after init_base_projective
matrix_group::init_base done
matrix_group::init_projective_group after init_base
matrix_group::init_projective_group finished
action::init_projective_group low_level_point_size=3
action::init_projective_group label=PGL_3_2
action::setup_linear_group_from_strong_generators setting up a basis
action::setup_linear_group_from_strong_generators before init_matrix_group_strong_generators_builtin
action::init_matrix_group_strong_generators_builtin
action::init_matrix_group_strong_generators_builtin computing strong generators builtin group
n=3
q=2
p=2
e=1
f_semilinear=0
strong_generators_for_projective_linear_group
generators for entries in the last row (e=1):
generators for entries in the last row (e=1):
generators for swaps along the diagonal:
generators for swaps along the diagonal:
strong_generators_for_projective_linear_group done
strong_generators::init_from_data
strong_generators::init
strong_generators::init done
strong_generators::init_from_data generator 0: 
1 0 0 
0 1 0 
1 0 1 
strong_generators::init_from_data generator 1: 
1 0 0 
0 1 0 
0 1 1 
strong_generators::init_from_data generator 2: 
1 0 0 
0 0 1 
0 1 0 
strong_generators::init_from_data generator 3: 
0 1 0 
1 0 0 
0 0 1 
strong_generators::init_from_data done
action::init_matrix_group_strong_generators_builtin computing strong generators builtin group finished
action::setup_linear_group_from_strong_generators after init_matrix_group_strong_generators_builtin
action::setup_linear_group_from_strong_generators before S->compute_base_orbits_known_length
sims::compute_base_orbits_known_length: ( 7, 6, 4 )
verbose_level=17
sims::compute_base_orbits_known_length computing level 2
sims::compute_base_orbits_known_length level 2 base point 2 orbit length 4 has been computed
sims::compute_base_orbits_known_length computing level 1
sims::compute_base_orbits_known_length level 1 base point 1 orbit length 6 has been computed
sims::compute_base_orbits_known_length computing level 0
sims::compute_base_orbits_known_length level 0 base point 0 orbit length 7 has been computed
sims::compute_base_orbits_known_length done
action::setup_linear_group_from_strong_generators before init_sims
action::init_sims action PGL_3_2 base_len = 3
action::init_base_from_sims, base length 3
action::init_sims done
action::setup_linear_group_from_strong_generators after init_sims
action::init_projective_group, finished setting up PGL_3_2, a permutation group of degree 7 and of order 168
code_generator::init finished with init_matrix_group
code_generator::init calling init_matrix_group_strong_generators_builtin_projective
action::init_matrix_group_strong_generators_builtin
action::init_matrix_group_strong_generators_builtin computing strong generators builtin group
n=3
q=2
p=2
e=1
f_semilinear=0
strong_generators_for_projective_linear_group
generators for entries in the last row (e=1):
generators for entries in the last row (e=1):
generators for swaps along the diagonal:
generators for swaps along the diagonal:
strong_generators_for_projective_linear_group done
strong_generators::init_from_data
strong_generators::init
strong_generators::init done
strong_generators::init_from_data generator 0: 
1 0 0 
0 1 0 
1 0 1 
strong_generators::init_from_data generator 1: 
1 0 0 
0 1 0 
0 1 1 
strong_generators::init_from_data generator 2: 
1 0 0 
0 0 1 
0 1 0 
strong_generators::init_from_data generator 3: 
0 1 0 
1 0 0 
0 0 1 
strong_generators::init_from_data done
action::init_matrix_group_strong_generators_builtin computing strong generators builtin group finished
code_generator::init finished with init_matrix_group_strong_generators_builtin_projective
code_generator::init group set up, calling gen->init
A->f_has_strong_generators=1
generator::init
generator::init sz = 7
generator::init A->degree=7
generator::init A2->degree=7
generator::init sz = 7
generator::init action A:
ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
generator::init action A2:
ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
generator::init group order is 168
generator::init sz = 7
generator::init allocating S of size 7
generator::init allocating Elt_memory
generator::init done
code_generator::init group set up, calling gen->init_early_test_func
generator::init_early_test_func
code_generator::init group set up, calling gen->init_oracle
generator::init_oracle
generator::init_oracle done
code_generator::init group set up, calling gen->root[0].init_root_node
oracle::init_root_node() initializing root node
storing strong generators
init_root_node done
generator::main
generator::main  depth = 7
f_W = 0
f_w = 0
verbose_level = 20
generator::main target_depth=7
generator::main:  calling extend_level 0
we will store schreier vectors for this level
##################################################################################################

generator::extend_level constructing nodes at depth 1
verbose_level=18
generator::extend_level 0 calling downstep
##################################################################################################

downstep depth 0 verbose_level=17
Time 
clock ticks per second = 100
0:00 : Level 0 Node 0 = 0 / 1 :  Downstep node starting
oracle::downstep
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : Downstep for {  }_{7 * 6 * 4 = 168} verbose_level=15
{  }_{7 * 6 * 4 = 168}
oracle::downstep before downstep_orbits
Time 0:00 : Level 0 Node 0 = 0 / 1 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_orbits we are trying to find an invariant subset
oracle::downstep_get_invariant_subset
oracle::downstep_get_invariant_subset done
We did not find an invariant subset
schreier::init_generators_by_hdl
nb_gen = 4
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 7 total length 7 degree=7
schreier::compute_all_point_orbits found 1 orbits
The distribution of orbit lengths is: ( 7 )
Time 0:00 : Level 0 Node 0 = 0 / 1 : The 1 orbits are:
   0 :     7 :     0 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 0 Node 0 = 0 / 1 : oracle::downstep_orbits: we found 1 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 0 Node 0 = 0 / 1 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=0
oracle::check_orbits
f_use_incremental_test_func_if_available=0
f_using_invariant_subset=0
check_orbits: testing 1 orbits
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 0 of point 0 of length 7 is accepted as orbit 0
check_orbits: orbit testing finished: 1 orbits out of 1 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     7
the stabilizer has 1 good orbits with 7 points
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : after check_orbits_wrapper:
nb_good_orbits=1
nb_points=7
Time 0:00 : Level 0 Node 0 = 0 / 1 : The 1 orbits are:
   0 :     7 :     0 : ( 0, 1, 2, 3, 4, 5, 6 )
calling get_schreier_vector
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : after creating Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 0 Node 0 = 0 / 1 : oracle::downstep_implicit_fusion
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 1 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : after test_orbits and find_extensions, we have 1 extensions
oracle::print_extensions node=0 at depth 0 degree=7
Node 0, the extensions are
i : pt : orbit_len : type : to where
    0 :       0 :     7 :    unprocessed    0
done with node 0
Time 0:00 : Level 0 Node 0 = 0 / 1 :  : found 1 extensions (out of 1 orbits) with 7 points 
oracle::downstep done

Downstep node finished :  found 7 live points in 1 orbits : oracle::print_extensions node=0 at depth 0 degree=7
Node 0, the extensions are
i : pt : orbit_len : type : to where
    0 :       0 :     7 :    unprocessed    0
done with node 0
progress: 0. 0 % 
generator::extend_level after downstep
generator::extend_level calling upstep
generator::upstep
verbose_level = 17
##################################################################################################

extension step depth 0
verbose_level=17
f_indicate_not_canonicals=0
with 1 extension nodes
generator::upstep case 0 / 1
Time 0:00 : Level 0 Node 0 = 0 / 1 :  Upstep : 
generator::extend_node prev=0 cur=1
Time 0:00 : Level 0 Node 0 = 0 / 1 :  extending set {  }_{7 * 6 * 4 = 168} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 1 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 1:
upstep_work::init size=0 prev=0 prev_ex=0 cur=1
upstep_work::init path: ( 0 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=0 prev_ex=0
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : with point 0 : 
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : with point 0 : before init_extension_node
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node cur=1 verbose_level=8
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node initializing Node 1 ( 0 ) f_indicate_not_canonicals=0 verbose_level=8
point 0 lies in an orbit of length 7 verbose_level = 8
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : { 0 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 1, 2, 3, 4 )
verbose_level=4
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 4 strong generators
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 7, 6, 4 ) and with 4 strong generators
generator 0:
1 0 0 
0 1 0 
1 0 1 

generator 1:
1 0 0 
0 1 0 
0 1 1 

generator 2:
1 0 0 
0 0 1 
0 1 0 

generator 3:
0 1 0 
1 0 0 
0 0 1 

>>>>G order before168>>>>G order after168Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )_{168}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : { 0 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : { 0 }
generator matrix:
1 
0 
0 
(orbit length = 7)
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : { 0 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=0,orblen7,go_G168,go_HNULL
oracle::init_extension_node_prepare_H
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )oracle::init_extension_node_prepare_H computing stabilizer of point 0 (of index 7 in a group of order 168 = 7 * 6 * 4)
verbose_level=4
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )oracle::init_extension_node_prepare_H computing stabilizer of point 0 in group of order 168
Level 0 Node 0 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 0 Node 0 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 168 orbit_len = 7 stab_order = NULL
Level 0 Node 0 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )oracle::init_extension_node_prepare_H point stabilizer has order 24, of index = 7 in 168
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 1, 6, 4 ) and with 3 strong generators
generator 0:
1 0 0 
0 1 0 
1 0 1 

(0)(4)(1)(2, 5)(3, 6)
generator 1:
1 0 0 
0 1 0 
1 1 1 

(0)(1)(4)(2, 3)(5, 6)
generator 2:
1 0 0 
0 0 1 
0 1 0 

(6)(3)(0)(4, 5)(1, 2)
oracle::init_extension_node_prepare_H done
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : { 0 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )upstep_work::init_extension_node calling upstep
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )upstep_work::init_extension_node calling upstep_for_sets
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : upstep for set { 0 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 1
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=1
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res1
ACTION PGL_3_2_res1 degree=1 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : initializing up_orbit with restricted action ACTION PGL_3_2_res1 degree=1 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : initializing up_orbit with generators
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : computing orbit of point 0
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : upstep_work::upstep_for_sets upstep orbit length for set { 0 } is 1
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 24, orbit length 1, new group order 24
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 3 strong generators
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )extension with point 0 : 
after upstep_for_sets/upstep_subspace_action
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )_{24}
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : ( 0 )_{24} (double check)
upstep_work::init_extension_node done
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : with point 0 : done 
nb_cosets_processed=0
init_extension_node returns TRUE
cur=2
Level 0 Node 0 = 0 / 1 Extension 0 / 1 : with point 0 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=0 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 1:
generator::extend_node after freeing Work
Time 0:00 : Level 0 Node 0 = 0 / 1 :  **** Upstep finished with 1 new orbits and 0 fusion nodes. We now have 1 nodes at level 1, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
Time 0:00 : Level 0 Node 0 = 0 / 1 :  Upstep : progress: 100. 0 % 
generator::extend_level after upstep
generator::housekeeping verbose_level=19
##################################################################################################
Found 1 orbits at depth 1
0 : 1 orbits
1 : 1 orbits
total: 2
(24) average is 24 + 0 / 1
# 1
1 0 24 adaaaaaaadaaaaaaaaaaaaaaabaaaaaaacaaaaaaabaaaaaaagaaaaaaaeaaaaaafbabnbabkbaa
-1 1 1 in 0:00
(24) average is 24 + 0 / 1

# in action PGL_3_2
generator_housekeeping not writing files
generator_housekeeping not writing tree
generator::housekeeping done
generator::main:  calling extend_level 1
we will store schreier vectors for this level
##################################################################################################

generator::extend_level constructing nodes at depth 2
verbose_level=18
generator::extend_level 1 calling downstep
##################################################################################################

downstep depth 1 verbose_level=17
Time 0:00 : Level 1 Node 1 = 0 / 1 :  Downstep node starting
oracle::downstep
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : Downstep for { 0 }_{1 * 6 * 4 = 24} verbose_level=15
{ 0 }_{1 * 6 * 4 = 24}
generator matrix:
1 
0 
0 
oracle::downstep before downstep_orbits
Time 0:00 : Level 1 Node 1 = 0 / 1 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 1 Node 1 = 0 / 1 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0 ) testing 7 candidates
check_mindist_early_test_func for { 0 }_{1 * 6 * 4 = 24}
after Schreier.compute_all_orbits_on_invariant_subset, we found 2 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 0 }

1 1 
0 0 
0 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1 }

1 0 
0 1 
0 0 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 2 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 3
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 1 total length 1 degree=7
schreier::compute_all_point_orbits pt = 1 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 1 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 1
found orbit of length 6 total length 7 degree=7
schreier::compute_all_point_orbits found 2 orbits
The distribution of orbit lengths is: ( 1, 6 )
Time 0:00 : Level 1 Node 1 = 0 / 1 : The 2 orbits are:
   0 :     1 :     0 : ( 0 )
   1 :     6 :     1 : ( 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 1 Node 1 = 0 / 1 : oracle::downstep_orbits: we found 2 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 1 Node 1 = 0 / 1 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 2 orbits
orbit 0 of point 0 of length 1 is accepted as orbit 0
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 1 of point 1 of length 6 is accepted as orbit 1
check_orbits: orbit testing finished: 2 orbits out of 2 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     1
    1 :     1 :     6
the stabilizer has 2 good orbits with 7 points
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : after check_orbits_wrapper:
nb_good_orbits=2
nb_points=7
Time 0:00 : Level 1 Node 1 = 0 / 1 : The 2 orbits are:
   0 :     1 :     0 : ( 0 )
   1 :     6 :     1 : ( 1, 2, 3, 4, 5, 6 )
calling get_schreier_vector
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :    -1 :    -1
    2 :     2 :     1 :     2
    3 :     3 :     2 :     1
    4 :     4 :     5 :     2
    5 :     5 :     2 :     0
    6 :     6 :     5 :     1
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :    -1 :    -1
    2 :     2 :     1 :     2
    3 :     3 :     2 :     1
    4 :     4 :     5 :     2
    5 :     5 :     2 :     0
    6 :     6 :     5 :     1
oracle::relabel_schreier_vector done
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 1 Node 1 = 0 / 1 : oracle::downstep_implicit_fusion
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 2 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : after test_orbits and find_extensions, we have 1 extensions
oracle::print_extensions node=1 at depth 1 degree=7
Node 1, the extensions are
i : pt : orbit_len : type : to where
    0 :       1 :     6 :    unprocessed    0
done with node 1
Time 0:00 : Level 1 Node 1 = 0 / 1 :  : found 1 extensions (out of 2 orbits) with 6 points 
oracle::downstep done

Downstep node finished :  found 7 live points in 1 orbits : oracle::print_extensions node=1 at depth 1 degree=7
Node 1, the extensions are
i : pt : orbit_len : type : to where
    0 :       1 :     6 :    unprocessed    0
done with node 1
progress: 0. 0 % 
generator::extend_level after downstep
generator::extend_level calling upstep
generator::upstep
verbose_level = 17
##################################################################################################

extension step depth 1
verbose_level=17
f_indicate_not_canonicals=0
with 1 extension nodes
generator::upstep case 0 / 1
Time 0:00 : Level 1 Node 1 = 0 / 1 :  Upstep : 
generator::extend_node prev=1 cur=2
Time 0:00 : Level 1 Node 1 = 0 / 1 :  extending set { 0 }_{1 * 6 * 4 = 24} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 1 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 1:
upstep_work::init size=1 prev=1 prev_ex=0 cur=2
upstep_work::init path: ( 0, 1 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=1 prev_ex=0
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : with point 1 : 
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : with point 1 : before init_extension_node
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node cur=2 verbose_level=8
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node initializing Node 2 ( 0, 1 ) f_indicate_not_canonicals=0 verbose_level=8
point 1 lies in an orbit of length 6 verbose_level = 8
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : { 0, 1 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 5, 6, 7 )
verbose_level=4
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 3 strong generators
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 1, 6, 4 ) and with 3 strong generators
generator 0:
1 0 0 
0 1 0 
1 0 1 

generator 1:
1 0 0 
0 1 0 
1 1 1 

generator 2:
1 0 0 
0 0 1 
0 1 0 

>>>>G order before24>>>>G order after24Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )_{24}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : { 0, 1 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : { 0, 1 }
generator matrix:
1 0 
0 1 
0 0 
(orbit length = 6)
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : { 0, 1 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=1,orblen6,go_G24,go_HNULL
oracle::init_extension_node_prepare_H
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )oracle::init_extension_node_prepare_H computing stabilizer of point 1 (of index 6 in a group of order 24 = 1 * 6 * 4)
verbose_level=4
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )oracle::init_extension_node_prepare_H computing stabilizer of point 1 in group of order 24
Level 1 Node 1 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 1 Node 1 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 24 orbit_len = 6 stab_order = NULL
Level 1 Node 1 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )oracle::init_extension_node_prepare_H point stabilizer has order 4, of index = 6 in 24
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 1, 1, 4 ) and with 2 strong generators
generator 0:
1 0 0 
0 1 0 
1 0 1 

(0)(4)(1)(2, 5)(3, 6)
generator 1:
1 0 0 
0 1 0 
0 1 1 

(0)(4)(1)(2, 6)(3, 5)
oracle::init_extension_node_prepare_H done
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : { 0, 1 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )upstep_work::init_extension_node calling upstep
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )upstep_work::init_extension_node calling upstep_for_sets
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : upstep for set { 0, 1 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 2
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=2
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res2
ACTION PGL_3_2_res2 degree=2 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : initializing up_orbit with restricted action ACTION PGL_3_2_res2 degree=2 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : initializing up_orbit with generators
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : computing orbit of point 1
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    1 :    1
upstep_work::upstep_for_sets coset=0
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : Coset 0 / 2 :  we are trying to map 0 to 1
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : Coset 0 / 2 :  orbit length upstep so far: 1 checking possible image 0
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : Coset 0 / 2 : exchanged set: { 1, 0 }
calling find_automorphism()
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : Coset 0 / 2 : ( 1, 0 )
generator matrix:
0 1 
1 0 
0 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::handle_last_level lvl=1 node=1 current_node=1 current_extension=0 pt0=1
oracle::handle_last_level my_current_node=2
upstep_work::handle_last_level: at (1/0) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : Coset 0 / 2 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : Coset 0 / 2 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : Coset 0 / 2 : upstep_work::upstep_for_sets found automorphism mapping 0 to 1
extend_orbit() extending orbit 0 of length 1
schreier::extend_orbit orbit extended to length 2
upstep_work::upstep_for_sets new orbit length upstep = 2
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1 } is 2
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 4, orbit length 2, new group order 8
sims::random_element
sims::random_element orbit_len=( 1, 1, 4 )
sims::random_element
path=( 0, 0, 0 )
sims::element_from_path
path=( 0, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 1, random element { 0, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 8 of 8 with 3 strong generators
remaining factor: 1 remainder 0
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 3 strong generators
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )extension with point 1 : 
after upstep_for_sets/upstep_subspace_action
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )_{8}
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : ( 0, 1 )_{8} (double check)
upstep_work::init_extension_node done
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : with point 1 : done 
nb_cosets_processed=1
init_extension_node returns TRUE
cur=3
Level 1 Node 1 = 0 / 1 Extension 0 / 1 : with point 1 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=1 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 1:
generator::extend_node after freeing Work
Time 0:00 : Level 1 Node 1 = 0 / 1 :  **** Upstep finished with 1 new orbits and 0 fusion nodes. We now have 1 nodes at level 2, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
Time 0:00 : Level 1 Node 1 = 0 / 1 :  Upstep : progress: 100. 0 % 
generator::extend_level after upstep
generator::housekeeping verbose_level=19
##################################################################################################
Found 1 orbits at depth 2
0 : 1 orbits
1 : 1 orbits
2 : 1 orbits
total: 3
(8) average is 8 + 0 / 1
# 2
2 0 1 8 adaaaaaaadaaaaaaaaaaaaaaabaaaaaaacaaaaaaacaaaaaaabaaaaaaaeaaaaaafbabjbabakab
-1 1 2 in 0:00
(8) average is 8 + 0 / 1

# in action PGL_3_2
generator_housekeeping not writing files
generator_housekeeping not writing tree
generator::housekeeping done
generator::main:  calling extend_level 2
we will store schreier vectors for this level
##################################################################################################

generator::extend_level constructing nodes at depth 3
verbose_level=18
generator::extend_level 2 calling downstep
##################################################################################################

downstep depth 2 verbose_level=17
Time 0:00 : Level 2 Node 2 = 0 / 1 :  Downstep node starting
oracle::downstep
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : Downstep for { 0, 1 }_{2 * 1 * 4 = 8} verbose_level=15
{ 0, 1 }_{2 * 1 * 4 = 8}
generator matrix:
1 0 
0 1 
0 0 
oracle::downstep before downstep_orbits
Time 0:00 : Level 2 Node 2 = 0 / 1 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 2 Node 2 = 0 / 1 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0, 1 ) testing 7 candidates
check_mindist_early_test_func for { 0, 1 }_{2 * 1 * 4 = 8}
after Schreier.compute_all_orbits_on_invariant_subset, we found 3 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 0 }

1 0 1 
0 1 0 
0 0 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2 }

1 0 0 
0 1 0 
0 0 1 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 4 }

1 0 1 
0 1 1 
0 0 0 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 3 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 3
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 2 total length 2 degree=7
schreier::compute_all_point_orbits pt = 2 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 2 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 2
found orbit of length 4 total length 6 degree=7
schreier::compute_all_point_orbits pt = 4 / 7 nb_orbits=2 computing orbit
schreier::compute_point_orbit computing orbit of point 4 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 4
found orbit of length 1 total length 7 degree=7
schreier::compute_all_point_orbits found 3 orbits
The distribution of orbit lengths is: ( 1, 2, 4 )
Time 0:00 : Level 2 Node 2 = 0 / 1 : The 3 orbits are:
   0 :     2 :     0 : ( 0, 1 )
   1 :     4 :     2 : ( 2, 3, 5, 6 )
   2 :     1 :     4 : ( 4 )
Time 0:00 : Level 2 Node 2 = 0 / 1 : oracle::downstep_orbits: we found 3 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 2 Node 2 = 0 / 1 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 3 orbits
orbit 0 of point 0 of length 2 is accepted as orbit 0
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 1 of point 2 of length 4 is accepted as orbit 1
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 2 of point 4 of length 1 is accepted as orbit 2
check_orbits: orbit testing finished: 3 orbits out of 3 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     2
    1 :     2 :     4
    2 :     4 :     1
the stabilizer has 3 good orbits with 7 points
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : after check_orbits_wrapper:
nb_good_orbits=3
nb_points=7
Time 0:00 : Level 2 Node 2 = 0 / 1 : The 3 orbits are:
   0 :     2 :     0 : ( 0, 1 )
   1 :     4 :     2 : ( 2, 3, 5, 6 )
   2 :     1 :     4 : ( 4 )
calling get_schreier_vector
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     2
    2 :     2 :    -1 :    -1
    3 :     3 :     5 :     1
    4 :     4 :    -1 :    -1
    5 :     5 :     2 :     0
    6 :     6 :     2 :     1
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     2
    2 :     2 :    -1 :    -1
    3 :     3 :     5 :     1
    4 :     4 :    -1 :    -1
    5 :     5 :     2 :     0
    6 :     6 :     2 :     1
oracle::relabel_schreier_vector done
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 2 Node 2 = 0 / 1 : oracle::downstep_implicit_fusion
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 3 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : after test_orbits and find_extensions, we have 2 extensions
oracle::print_extensions node=2 at depth 2 degree=7
Node 2, the extensions are
i : pt : orbit_len : type : to where
    0 :       2 :     4 :    unprocessed    0
    1 :       4 :     1 :    unprocessed    0
done with node 2
Time 0:00 : Level 2 Node 2 = 0 / 1 :  : found 2 extensions (out of 3 orbits) with 5 points 
oracle::downstep done

Downstep node finished :  found 7 live points in 2 orbits : oracle::print_extensions node=2 at depth 2 degree=7
Node 2, the extensions are
i : pt : orbit_len : type : to where
    0 :       2 :     4 :    unprocessed    0
    1 :       4 :     1 :    unprocessed    0
done with node 2
progress: 0. 0 % 
generator::extend_level after downstep
generator::extend_level calling upstep
generator::upstep
verbose_level = 17
##################################################################################################

extension step depth 2
verbose_level=17
f_indicate_not_canonicals=0
with 2 extension nodes
generator::upstep case 0 / 1
Time 0:00 : Level 2 Node 2 = 0 / 1 :  Upstep : 
generator::extend_node prev=2 cur=3
Time 0:00 : Level 2 Node 2 = 0 / 1 :  extending set { 0, 1 }_{2 * 1 * 4 = 8} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 2 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 2:
upstep_work::init size=2 prev=2 prev_ex=0 cur=3
upstep_work::init path: ( 0, 1, 2 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=2 prev_ex=0
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : with point 2 : 
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : with point 2 : before init_extension_node
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : upstep_work::init_extension_node cur=3 verbose_level=8
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : upstep_work::init_extension_node initializing Node 3 ( 0, 1, 2 ) f_indicate_not_canonicals=0 verbose_level=8
point 2 lies in an orbit of length 4 verbose_level = 8
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : { 0, 1, 2 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 8, 9, 10 )
verbose_level=4
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 3 strong generators
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 2, 1, 4 ) and with 3 strong generators
generator 0:
1 0 0 
0 1 0 
1 0 1 

generator 1:
1 0 0 
0 1 0 
0 1 1 

generator 2:
0 1 0 
1 0 0 
0 0 1 

>>>>G order before8>>>>G order after8Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )_{8}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : { 0, 1, 2 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : { 0, 1, 2 }
generator matrix:
1 0 0 
0 1 0 
0 0 1 
(orbit length = 4)
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : { 0, 1, 2 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=2,orblen4,go_G8,go_HNULL
oracle::init_extension_node_prepare_H
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )oracle::init_extension_node_prepare_H computing stabilizer of point 2 (of index 4 in a group of order 8 = 2 * 1 * 4)
verbose_level=4
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )oracle::init_extension_node_prepare_H computing stabilizer of point 2 in group of order 8
Level 2 Node 2 = 0 / 1 Extension 0 / 2 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 2 Node 2 = 0 / 1 Extension 0 / 2 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 8 orbit_len = 4 stab_order = NULL
Level 2 Node 2 = 0 / 1 Extension 0 / 2 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )oracle::init_extension_node_prepare_H point stabilizer has order 2, of index = 4 in 8
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 2, 1, 1 ) and with 1 strong generators
generator 0:
0 1 0 
1 0 0 
0 0 1 

(2)(3)(4)(5, 6)(0, 1)
oracle::init_extension_node_prepare_H done
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : { 0, 1, 2 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )upstep_work::init_extension_node calling upstep
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )upstep_work::init_extension_node calling upstep_for_sets
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : upstep for set { 0, 1, 2 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 3
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=3
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res3
ACTION PGL_3_2_res3 degree=3 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : initializing up_orbit with restricted action ACTION PGL_3_2_res3 degree=3 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : initializing up_orbit with generators
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : computing orbit of point 2
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    0 :    1
   2 :    2 :    2
upstep_work::upstep_for_sets coset=0
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 0 / 3 :  we are trying to map 0 to 2
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 0 / 3 :  orbit length upstep so far: 1 checking possible image 0
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 0 / 3 : exchanged set: { 2, 1, 0 }
calling find_automorphism()
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 0 / 3 : ( 2, 1, 0 )
generator matrix:
0 0 1 
0 1 0 
1 0 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::handle_last_level lvl=2 node=2 current_node=2 current_extension=0 pt0=2
oracle::handle_last_level my_current_node=3
upstep_work::handle_last_level: at (2/0) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 0 / 3 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 0 / 3 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 0 / 3 : upstep_work::upstep_for_sets found automorphism mapping 0 to 2
extend_orbit() extending orbit 0 of length 1
schreier::extend_orbit orbit extended to length 3
upstep_work::upstep_for_sets new orbit length upstep = 3
upstep_work::upstep_for_sets coset=1
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : Coset 1 / 3 :  we are trying to map 1 to 2
coset 1 is at 0 which has already been done, so we save one trace
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1, 2 } is 3
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 2, orbit length 3, new group order 6
sims::random_element
sims::random_element orbit_len=( 2, 1, 1 )
sims::random_element
path=( 0, 0, 0 )
sims::element_from_path
path=( 0, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 1, random element { 0, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 3 of 6 with 2 strong generators
remaining factor: 2 remainder 0
sims::random_element
sims::random_element orbit_len=( 3, 1, 1 )
sims::random_element
path=( 2, 0, 0 )
sims::element_from_path
path=( 2, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 2 before coset_rep
sims::coset_rep i=0 j=2
sims::coset_rep i=0 j=2
cosetrep:
0 0 1 
0 1 0 
1 0 0 
sims::element_from_path level 0 coset 2 after coset_rep
sims::element_from_path level 0 coset 2:
cosetrep:
0 0 1 
0 1 0 
1 0 0 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 2, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 6 of 6 with 3 strong generators
remaining factor: 1 remainder 0
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 3 strong generators
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )extension with point 2 : 
after upstep_for_sets/upstep_subspace_action
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )_{6}
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : ( 0, 1, 2 )_{6} (double check)
upstep_work::init_extension_node done
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : with point 2 : done 
nb_cosets_processed=1
init_extension_node returns TRUE
cur=4
Level 2 Node 2 = 0 / 1 Extension 0 / 2 : with point 2 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=2 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 2:
generator::extend_node after freeing Work
generator::extend_node working on extension 1 / 2:
upstep_work::init size=2 prev=2 prev_ex=1 cur=4
upstep_work::init path: ( 0, 1, 2 )
upstep_work::init done
Time 0:00 : Level 2 Node 2 = 0 / 1 :  **** Upstep extension 1 / 2 with 1 new orbits and 0 fusion nodes. We now have 1 nodes at level 3, progress: 50. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          1 :          0 :          2 :          1
upstep_work::handle_extension verbose_level = 11
prev=2 prev_ex=1
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : with point 4 : 
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : with point 4 : before init_extension_node
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : upstep_work::init_extension_node cur=4 verbose_level=8
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : upstep_work::init_extension_node initializing Node 4 ( 0, 1, 4 ) f_indicate_not_canonicals=0 verbose_level=8
point 4 lies in an orbit of length 1 verbose_level = 8
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : { 0, 1, 4 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 8, 9, 10 )
verbose_level=4
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 3 strong generators
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 2, 1, 4 ) and with 3 strong generators
generator 0:
1 0 0 
0 1 0 
1 0 1 

generator 1:
1 0 0 
0 1 0 
0 1 1 

generator 2:
0 1 0 
1 0 0 
0 0 1 

>>>>G order before8>>>>G order after8Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )_{8}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : { 0, 1, 4 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : { 0, 1, 4 }
generator matrix:
1 0 1 
0 1 1 
0 0 0 
(orbit length = 1)
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : { 0, 1, 4 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=4,orblen1,go_G8,go_HNULL
oracle::init_extension_node_prepare_H
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )oracle::init_extension_node_prepare_H computing stabilizer of point 4 (of index 1 in a group of order 8 = 2 * 1 * 4)
verbose_level=4
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )oracle::init_extension_node_prepare_H computing stabilizer of point 4 in group of order 8
Level 2 Node 2 = 0 / 1 Extension 1 / 2 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 2 Node 2 = 0 / 1 Extension 1 / 2 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 8 orbit_len = 1 stab_order = NULL
Level 2 Node 2 = 0 / 1 Extension 1 / 2 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )oracle::init_extension_node_prepare_H point stabilizer has order 8, of index = 1 in 8
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 2, 1, 4 ) and with 3 strong generators
generator 0:
1 0 0 
0 1 0 
0 1 1 

(0)(4)(1)(2, 6)(3, 5)
generator 1:
1 0 0 
0 1 0 
1 0 1 

(0)(4)(1)(2, 5)(3, 6)
generator 2:
0 1 0 
1 0 0 
0 0 1 

(2)(3)(4)(5, 6)(0, 1)
oracle::init_extension_node_prepare_H done
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : { 0, 1, 4 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )upstep_work::init_extension_node calling upstep
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )upstep_work::init_extension_node calling upstep_for_sets
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : upstep for set { 0, 1, 4 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 3
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=3
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res3
ACTION PGL_3_2_res3 degree=3 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : initializing up_orbit with restricted action ACTION PGL_3_2_res3 degree=3 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : initializing up_orbit with generators
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : computing orbit of point 4
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    0 :    1
   2 :    2 :    2
upstep_work::upstep_for_sets coset=0
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 0 / 3 :  we are trying to map 0 to 4
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 0 / 3 :  orbit length upstep so far: 1 checking possible image 0
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 0 / 3 : exchanged set: { 4, 1, 0 }
calling find_automorphism()
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 0 / 3 : ( 4, 1, 0 )
generator matrix:
1 0 1 
1 1 0 
0 0 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::handle_last_level lvl=2 node=2 current_node=2 current_extension=1 pt0=4
oracle::handle_last_level my_current_node=4
upstep_work::handle_last_level: at (2/1) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 0 / 3 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 0 / 3 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 0 / 3 : upstep_work::upstep_for_sets found automorphism mapping 0 to 4
extend_orbit() extending orbit 0 of length 1
schreier::extend_orbit orbit extended to length 3
upstep_work::upstep_for_sets new orbit length upstep = 3
upstep_work::upstep_for_sets coset=1
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : Coset 1 / 3 :  we are trying to map 1 to 4
coset 1 is at 0 which has already been done, so we save one trace
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1, 4 } is 3
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 8, orbit length 3, new group order 24
sims::random_element
sims::random_element orbit_len=( 2, 1, 4 )
sims::random_element
path=( 1, 0, 1 )
sims::element_from_path
path=( 1, 0, 1 )
A->degree=7
sims::element_from_path level 0 coset 1 before coset_rep
sims::coset_rep i=0 j=1
sims::coset_rep i=0 j=1
cosetrep:
0 1 0 
1 0 0 
0 0 1 
sims::element_from_path level 0 coset 1 after coset_rep
sims::element_from_path level 0 coset 1:
cosetrep:
0 1 0 
1 0 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 1 before coset_rep
sims::coset_rep i=2 j=1
sims::coset_rep i=2 j=1
cosetrep:
1 0 0 
0 1 0 
0 1 1 
sims::element_from_path level 2 coset 1 after coset_rep
sims::element_from_path level 2 coset 1:
cosetrep:
1 0 0 
0 1 0 
0 1 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 1, random element { 1, 0, 1 }
sims::transitive_extension_tolerant found an extension of order 12 of 24 with 4 strong generators
remaining factor: 2 remainder 0
sims::random_element
sims::random_element orbit_len=( 3, 1, 4 )
sims::random_element
path=( 0, 0, 2 )
sims::element_from_path
path=( 0, 0, 2 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 2 before coset_rep
sims::coset_rep i=2 j=2
sims::coset_rep i=2 j=2
cosetrep:
1 0 0 
0 1 0 
1 0 1 
sims::element_from_path level 2 coset 2 after coset_rep
sims::element_from_path level 2 coset 2:
cosetrep:
1 0 0 
0 1 0 
1 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 1, random element { 0, 0, 2 }
sims::transitive_extension_tolerant found an extension of order 24 of 24 with 5 strong generators
remaining factor: 1 remainder 0
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 5 strong generators
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )extension with point 4 : 
after upstep_for_sets/upstep_subspace_action
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )_{24}
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : ( 0, 1, 4 )_{24} (double check)
upstep_work::init_extension_node done
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : with point 4 : done 
nb_cosets_processed=1
init_extension_node returns TRUE
cur=5
Level 2 Node 2 = 0 / 1 Extension 1 / 2 : with point 4 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=2 prev_ex=1 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 1 / 2:
generator::extend_node after freeing Work
Time 0:00 : Level 2 Node 2 = 0 / 1 :  **** Upstep finished with 2 new orbits and 0 fusion nodes. We now have 2 nodes at level 3, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
Time 0:00 : Level 2 Node 2 = 0 / 1 :  Upstep : progress: 100. 0 % 
generator::extend_level after upstep
generator::housekeeping verbose_level=19
##################################################################################################
Found 2 orbits at depth 3
0 : 1 orbits
1 : 1 orbits
2 : 1 orbits
3 : 2 orbits
total: 5
(24, 6) average is 15 + 0 / 2
# 3
3 0 1 2 6 adaaaaaaadaaaaaaaaaaaaaaabaaaaaaacaaaaaaadaaaaaaacaaaaaaabaaaaaakbaaakabfeaa
3 0 1 4 24 adaaaaaaafaaaaaaaaaaaaaaabaaaaaaacaaaaaaadaaaaaaacaaaaaaaeaaaaaajbabfbabbjabakabelab
-1 2 3 in 0:00
(24, 6) average is 15 + 0 / 2

# in action PGL_3_2
generator_housekeeping not writing files
generator_housekeeping not writing tree
generator::housekeeping done
generator::main:  calling extend_level 3
we will store schreier vectors for this level
##################################################################################################

generator::extend_level constructing nodes at depth 4
verbose_level=18
generator::extend_level 3 calling downstep
##################################################################################################

downstep depth 3 verbose_level=17
Time 0:00 : Level 3 Node 3 = 0 / 2 :  Downstep node starting
oracle::downstep
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : Downstep for { 0, 1, 2 }_{3 * 2 * 1 = 6} verbose_level=15
{ 0, 1, 2 }_{3 * 2 * 1 = 6}
generator matrix:
1 0 0 
0 1 0 
0 0 1 
oracle::downstep before downstep_orbits
Time 0:00 : Level 3 Node 3 = 0 / 2 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 3 Node 3 = 0 / 2 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0, 1, 2 ) testing 7 candidates
check_mindist_early_test_func for { 0, 1, 2 }_{3 * 2 * 1 = 6}
after Schreier.compute_all_orbits_on_invariant_subset, we found 3 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 0 }

1 0 0 1 
0 1 0 0 
0 0 1 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3 }

1 0 0 1 
0 1 0 1 
0 0 1 1 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 4 }

1 0 0 1 
0 1 0 1 
0 0 1 0 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 3 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 3
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 3 total length 3 degree=7
schreier::compute_all_point_orbits pt = 3 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 3 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 3
found orbit of length 1 total length 4 degree=7
schreier::compute_all_point_orbits pt = 4 / 7 nb_orbits=2 computing orbit
schreier::compute_point_orbit computing orbit of point 4 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 4
found orbit of length 3 total length 7 degree=7
schreier::compute_all_point_orbits found 3 orbits
The distribution of orbit lengths is: ( 1, 3^2 )
Time 0:00 : Level 3 Node 3 = 0 / 2 : The 3 orbits are:
   0 :     3 :     0 : ( 0, 1, 2 )
   1 :     1 :     3 : ( 3 )
   2 :     3 :     4 : ( 4, 5, 6 )
Time 0:00 : Level 3 Node 3 = 0 / 2 : oracle::downstep_orbits: we found 3 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 3 Node 3 = 0 / 2 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 3 orbits
orbit 0 of point 0 of length 3 is accepted as orbit 0
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 1 of point 3 of length 1 is accepted as orbit 1
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 2 of point 4 of length 3 is accepted as orbit 2
check_orbits: orbit testing finished: 3 orbits out of 3 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     3
    1 :     3 :     1
    2 :     4 :     3
the stabilizer has 3 good orbits with 7 points
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : after check_orbits_wrapper:
nb_good_orbits=3
nb_points=7
Time 0:00 : Level 3 Node 3 = 0 / 2 : The 3 orbits are:
   0 :     3 :     0 : ( 0, 1, 2 )
   1 :     1 :     3 : ( 3 )
   2 :     3 :     4 : ( 4, 5, 6 )
calling get_schreier_vector
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     1
    2 :     2 :     0 :     2
    3 :     3 :    -1 :    -1
    4 :     4 :    -1 :    -1
    5 :     5 :     4 :     0
    6 :     6 :     4 :     2
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     1
    2 :     2 :     0 :     2
    3 :     3 :    -1 :    -1
    4 :     4 :    -1 :    -1
    5 :     5 :     4 :     0
    6 :     6 :     4 :     2
oracle::relabel_schreier_vector done
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 3 Node 3 = 0 / 2 : oracle::downstep_implicit_fusion
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 3 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : after test_orbits and find_extensions, we have 2 extensions
oracle::print_extensions node=3 at depth 3 degree=7
Node 3, the extensions are
i : pt : orbit_len : type : to where
    0 :       3 :     1 :    unprocessed    0
    1 :       4 :     3 :    unprocessed    0
done with node 3
Time 0:00 : Level 3 Node 3 = 0 / 2 :  : found 2 extensions (out of 3 orbits) with 4 points 
oracle::downstep done

Downstep node finished :  found 7 live points in 2 orbits : oracle::print_extensions node=3 at depth 3 degree=7
Node 3, the extensions are
i : pt : orbit_len : type : to where
    0 :       3 :     1 :    unprocessed    0
    1 :       4 :     3 :    unprocessed    0
done with node 3
progress: 0. 0 % 
oracle::downstep
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : Downstep for { 0, 1, 4 }_{3 * 2 * 4 = 24} verbose_level=15
{ 0, 1, 4 }_{3 * 2 * 4 = 24}
generator matrix:
1 0 1 
0 1 1 
0 0 0 
oracle::downstep before downstep_orbits
Time 0:00 : Level 3 Node 4 = 1 / 2 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 3 Node 4 = 1 / 2 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0, 1, 4 ) testing 7 candidates
check_mindist_early_test_func for { 0, 1, 4 }_{3 * 2 * 4 = 24}
after Schreier.compute_all_orbits_on_invariant_subset, we found 2 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 4, 0 }

1 0 1 1 
0 1 1 0 
0 0 0 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 4, 2 }

1 0 1 0 
0 1 1 0 
0 0 0 1 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 2 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 5
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 3 total length 3 degree=7
schreier::compute_all_point_orbits pt = 2 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 2 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 2
found orbit of length 4 total length 7 degree=7
schreier::compute_all_point_orbits found 2 orbits
The distribution of orbit lengths is: ( 3, 4 )
Time 0:00 : Level 3 Node 4 = 1 / 2 : The 2 orbits are:
   0 :     3 :     0 : ( 0, 1, 4 )
   1 :     4 :     2 : ( 2, 3, 5, 6 )
Time 0:00 : Level 3 Node 4 = 1 / 2 : oracle::downstep_orbits: we found 2 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 3 Node 4 = 1 / 2 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 2 orbits
orbit 0 of point 0 of length 3 is accepted as orbit 0
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 1 of point 2 of length 4 is accepted as orbit 1
check_orbits: orbit testing finished: 2 orbits out of 2 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     3
    1 :     2 :     4
the stabilizer has 2 good orbits with 7 points
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : after check_orbits_wrapper:
nb_good_orbits=2
nb_points=7
Time 0:00 : Level 3 Node 4 = 1 / 2 : The 2 orbits are:
   0 :     3 :     0 : ( 0, 1, 4 )
   1 :     4 :     2 : ( 2, 3, 5, 6 )
calling get_schreier_vector
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     3
    2 :     2 :    -1 :    -1
    3 :     3 :     6 :     1
    4 :     4 :     0 :     4
    5 :     5 :     2 :     1
    6 :     6 :     2 :     0
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     3
    2 :     2 :    -1 :    -1
    3 :     3 :     6 :     1
    4 :     4 :     0 :     4
    5 :     5 :     2 :     1
    6 :     6 :     2 :     0
oracle::relabel_schreier_vector done
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 3 Node 4 = 1 / 2 : oracle::downstep_implicit_fusion
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 2 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : after test_orbits and find_extensions, we have 1 extensions
oracle::print_extensions node=4 at depth 3 degree=7
Node 4, the extensions are
i : pt : orbit_len : type : to where
    0 :       2 :     4 :    unprocessed    0
done with node 4
Time 0:00 : Level 3 Node 4 = 1 / 2 :  : found 1 extensions (out of 2 orbits) with 4 points 
oracle::downstep done
generator::extend_level after downstep
generator::extend_level calling upstep
generator::upstep
verbose_level = 17
##################################################################################################

extension step depth 3
verbose_level=17
f_indicate_not_canonicals=0
with 3 extension nodes
generator::upstep case 0 / 2
Time 0:00 : Level 3 Node 3 = 0 / 2 :  Upstep : 
generator::extend_node prev=3 cur=5
Time 0:00 : Level 3 Node 3 = 0 / 2 :  extending set { 0, 1, 2 }_{3 * 2 * 1 = 6} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 2 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 2:
upstep_work::init size=3 prev=3 prev_ex=0 cur=5
upstep_work::init path: ( 0, 1, 2, 3 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=3 prev_ex=0
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : with point 3 : 
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : with point 3 : before init_extension_node
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : upstep_work::init_extension_node cur=5 verbose_level=8
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : upstep_work::init_extension_node initializing Node 5 ( 0, 1, 2, 3 ) f_indicate_not_canonicals=0 verbose_level=8
point 3 lies in an orbit of length 1 verbose_level = 8
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : { 0, 1, 2, 3 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 11, 12, 13 )
verbose_level=4
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 3 strong generators
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 3, 2, 1 ) and with 3 strong generators
generator 0:
1 0 0 
0 0 1 
0 1 0 

generator 1:
0 1 0 
1 0 0 
0 0 1 

generator 2:
0 0 1 
0 1 0 
1 0 0 

>>>>G order before6>>>>G order after6Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )_{6}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : { 0, 1, 2, 3 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : { 0, 1, 2, 3 }
generator matrix:
1 0 0 1 
0 1 0 1 
0 0 1 1 
(orbit length = 1)
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : { 0, 1, 2, 3 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=3,orblen1,go_G6,go_HNULL
oracle::init_extension_node_prepare_H
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )oracle::init_extension_node_prepare_H computing stabilizer of point 3 (of index 1 in a group of order 6 = 3 * 2)
verbose_level=4
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )oracle::init_extension_node_prepare_H computing stabilizer of point 3 in group of order 6
Level 3 Node 3 = 0 / 2 Extension 0 / 2 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 3 Node 3 = 0 / 2 Extension 0 / 2 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 6 orbit_len = 1 stab_order = NULL
Level 3 Node 3 = 0 / 2 Extension 0 / 2 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )oracle::init_extension_node_prepare_H point stabilizer has order 6, of index = 1 in 6
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 3, 2, 1 ) and with 2 strong generators
generator 0:
1 0 0 
0 0 1 
0 1 0 

(6)(3)(0)(4, 5)(1, 2)
generator 1:
0 0 1 
0 1 0 
1 0 0 

(5)(3)(1)(4, 6)(0, 2)
oracle::init_extension_node_prepare_H done
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : { 0, 1, 2, 3 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )upstep_work::init_extension_node calling upstep
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )upstep_work::init_extension_node calling upstep_for_sets
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : upstep for set { 0, 1, 2, 3 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 4
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=4
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res4
ACTION PGL_3_2_res4 degree=4 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : initializing up_orbit with restricted action ACTION PGL_3_2_res4 degree=4 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : initializing up_orbit with generators
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : computing orbit of point 3
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    1 :    1
   2 :    0 :    2
   3 :    3 :    3
upstep_work::upstep_for_sets coset=0
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 0 / 4 :  we are trying to map 0 to 3
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 0 / 4 :  orbit length upstep so far: 1 checking possible image 0
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 0 / 4 : exchanged set: { 3, 1, 2, 0 }
calling find_automorphism()
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 0 / 4 : ( 3, 1, 2, 0 )
generator matrix:
1 0 0 1 
1 1 0 0 
1 0 1 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/0) extension from 2 to 3
upstep_work::handle_last_level lvl=3 node=3 current_node=3 current_extension=0 pt0=3
oracle::handle_last_level my_current_node=5
upstep_work::handle_last_level: at (3/0) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 0 / 4 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 0 / 4 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 0 / 4 : upstep_work::upstep_for_sets found automorphism mapping 0 to 3
extend_orbit() extending orbit 0 of length 1
schreier::extend_orbit orbit extended to length 4
upstep_work::upstep_for_sets new orbit length upstep = 4
upstep_work::upstep_for_sets coset=1
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 1 / 4 :  we are trying to map 1 to 3
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 1 / 4 :  orbit length upstep so far: 4 checking possible image 1
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 1 / 4 : exchanged set: { 0, 3, 2, 1 }
calling find_automorphism()
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 1 / 4 : ( 0, 3, 2, 1 )
generator matrix:
1 1 0 0 
0 1 0 1 
0 1 1 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/0) extension from 2 to 3
upstep_work::handle_last_level lvl=3 node=3 current_node=3 current_extension=0 pt0=3
oracle::handle_last_level my_current_node=5
upstep_work::handle_last_level: at (3/0) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 1 / 4 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 1 / 4 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 1 / 4 : upstep_work::upstep_for_sets found automorphism mapping 1 to 3
extend_orbit() extending orbit 0 of length 4
schreier::extend_orbit orbit extended to length 4
upstep_work::upstep_for_sets new orbit length upstep = 4
upstep_work::upstep_for_sets coset=2
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : Coset 2 / 4 :  we are trying to map 2 to 3
coset 2 is at 0 which has already been done, so we save one trace
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1, 2, 3 } is 4
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 6, orbit length 4, new group order 24
sims::random_element
sims::random_element orbit_len=( 3, 2, 1 )
sims::random_element
path=( 0, 0, 0 )
sims::element_from_path
path=( 0, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 0, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 8 of 24 with 3 strong generators
remaining factor: 3 remainder 0
sims::random_element
sims::random_element orbit_len=( 4, 2, 1 )
sims::random_element
path=( 2, 1, 0 )
sims::element_from_path
path=( 2, 1, 0 )
A->degree=7
sims::element_from_path level 0 coset 2 before coset_rep
sims::coset_rep i=0 j=2
sims::coset_rep i=0 j=2
cosetrep:
0 1 0 
0 0 1 
1 0 0 
sims::element_from_path level 0 coset 2 after coset_rep
sims::element_from_path level 0 coset 2:
cosetrep:
0 1 0 
0 0 1 
1 0 0 

sims::element_from_path level 1 coset 1 before coset_rep
sims::coset_rep i=1 j=1
sims::coset_rep i=1 j=1
cosetrep:
1 0 0 
0 0 1 
0 1 0 
sims::element_from_path level 1 coset 1 after coset_rep
sims::element_from_path level 1 coset 1:
cosetrep:
1 0 0 
0 0 1 
0 1 0 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 2, 1, 0 }
sims::random_element
sims::random_element orbit_len=( 4, 2, 1 )
sims::random_element
path=( 0, 0, 0 )
sims::element_from_path
path=( 0, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 3, random element { 0, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 12 of 24 with 4 strong generators
remaining factor: 2 remainder 0
sims::random_element
sims::random_element orbit_len=( 4, 3, 1 )
sims::random_element
path=( 3, 1, 0 )
sims::element_from_path
path=( 3, 1, 0 )
A->degree=7
sims::element_from_path level 0 coset 3 before coset_rep
sims::coset_rep i=0 j=3
sims::coset_rep i=0 j=3
cosetrep:
1 1 1 
0 1 0 
1 0 0 
sims::element_from_path level 0 coset 3 after coset_rep
sims::element_from_path level 0 coset 3:
cosetrep:
1 1 1 
0 1 0 
1 0 0 

sims::element_from_path level 1 coset 1 before coset_rep
sims::coset_rep i=1 j=1
sims::coset_rep i=1 j=1
cosetrep:
1 0 0 
0 0 1 
0 1 0 
sims::element_from_path level 1 coset 1 after coset_rep
sims::element_from_path level 1 coset 1:
cosetrep:
1 0 0 
0 0 1 
0 1 0 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 1, random element { 3, 1, 0 }
sims::random_element
sims::random_element orbit_len=( 4, 3, 1 )
sims::random_element
path=( 0, 2, 0 )
sims::element_from_path
path=( 0, 2, 0 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 2 before coset_rep
sims::coset_rep i=1 j=2
sims::coset_rep i=1 j=2
cosetrep:
1 0 0 
1 1 1 
0 0 1 
sims::element_from_path level 1 coset 2 after coset_rep
sims::element_from_path level 1 coset 2:
cosetrep:
1 0 0 
1 1 1 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 3, random element { 0, 2, 0 }
sims::random_element
sims::random_element orbit_len=( 4, 3, 1 )
sims::random_element
path=( 0, 2, 0 )
sims::element_from_path
path=( 0, 2, 0 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 2 before coset_rep
sims::coset_rep i=1 j=2
sims::coset_rep i=1 j=2
cosetrep:
1 0 0 
1 1 1 
0 0 1 
sims::element_from_path level 1 coset 2 after coset_rep
sims::element_from_path level 1 coset 2:
cosetrep:
1 0 0 
1 1 1 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 3, random element { 0, 2, 0 }
sims::random_element
sims::random_element orbit_len=( 4, 3, 1 )
sims::random_element
path=( 2, 0, 0 )
sims::element_from_path
path=( 2, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 2 before coset_rep
sims::coset_rep i=0 j=2
sims::coset_rep i=0 j=2
cosetrep:
0 1 0 
0 0 1 
1 0 0 
sims::element_from_path level 0 coset 2 after coset_rep
sims::element_from_path level 0 coset 2:
cosetrep:
0 1 0 
0 0 1 
1 0 0 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 3, random element { 2, 0, 0 }
sims::random_element
sims::random_element orbit_len=( 4, 3, 1 )
sims::random_element
path=( 3, 2, 0 )
sims::element_from_path
path=( 3, 2, 0 )
A->degree=7
sims::element_from_path level 0 coset 3 before coset_rep
sims::coset_rep i=0 j=3
sims::coset_rep i=0 j=3
cosetrep:
1 1 1 
0 1 0 
1 0 0 
sims::element_from_path level 0 coset 3 after coset_rep
sims::element_from_path level 0 coset 3:
cosetrep:
1 1 1 
0 1 0 
1 0 0 

sims::element_from_path level 1 coset 2 before coset_rep
sims::coset_rep i=1 j=2
sims::coset_rep i=1 j=2
cosetrep:
1 0 0 
1 1 1 
0 0 1 
sims::element_from_path level 1 coset 2 after coset_rep
sims::element_from_path level 1 coset 2:
cosetrep:
1 0 0 
1 1 1 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 1, random element { 3, 2, 0 }
sims::random_element
sims::random_element orbit_len=( 4, 3, 1 )
sims::random_element
path=( 2, 1, 0 )
sims::element_from_path
path=( 2, 1, 0 )
A->degree=7
sims::element_from_path level 0 coset 2 before coset_rep
sims::coset_rep i=0 j=2
sims::coset_rep i=0 j=2
cosetrep:
0 1 0 
0 0 1 
1 0 0 
sims::element_from_path level 0 coset 2 after coset_rep
sims::element_from_path level 0 coset 2:
cosetrep:
0 1 0 
0 0 1 
1 0 0 

sims::element_from_path level 1 coset 1 before coset_rep
sims::coset_rep i=1 j=1
sims::coset_rep i=1 j=1
cosetrep:
1 0 0 
0 0 1 
0 1 0 
sims::element_from_path level 1 coset 1 after coset_rep
sims::element_from_path level 1 coset 1:
cosetrep:
1 0 0 
0 0 1 
0 1 0 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 2, 1, 0 }
sims::random_element
sims::random_element orbit_len=( 4, 3, 1 )
sims::random_element
path=( 3, 0, 0 )
sims::element_from_path
path=( 3, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 3 before coset_rep
sims::coset_rep i=0 j=3
sims::coset_rep i=0 j=3
cosetrep:
1 1 1 
0 1 0 
1 0 0 
sims::element_from_path level 0 coset 3 after coset_rep
sims::element_from_path level 0 coset 3:
cosetrep:
1 1 1 
0 1 0 
1 0 0 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 3, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 24 of 24 with 5 strong generators
remaining factor: 1 remainder 0
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 5 strong generators
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )extension with point 3 : 
after upstep_for_sets/upstep_subspace_action
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )_{24}
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : ( 0, 1, 2, 3 )_{24} (double check)
upstep_work::init_extension_node done
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : with point 3 : done 
nb_cosets_processed=2
init_extension_node returns TRUE
cur=6
Level 3 Node 3 = 0 / 2 Extension 0 / 2 : with point 3 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=3 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 2:
generator::extend_node after freeing Work
generator::extend_node working on extension 1 / 2:
upstep_work::init size=3 prev=3 prev_ex=1 cur=6
upstep_work::init path: ( 0, 1, 2, 3 )
upstep_work::init done
Time 0:00 : Level 3 Node 3 = 0 / 2 :  **** Upstep extension 1 / 2 with 1 new orbits and 0 fusion nodes. We now have 1 nodes at level 4, progress: 33.33 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
    3 :          1 :          0 :          3 :          2
upstep_work::handle_extension verbose_level = 11
prev=3 prev_ex=1
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : with point 4 : 
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : with point 4 : before init_extension_node
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : upstep_work::init_extension_node cur=6 verbose_level=8
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : upstep_work::init_extension_node initializing Node 6 ( 0, 1, 2, 4 ) f_indicate_not_canonicals=0 verbose_level=8
point 4 lies in an orbit of length 3 verbose_level = 8
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : { 0, 1, 2, 4 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 11, 12, 13 )
verbose_level=4
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 3 strong generators
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 3, 2, 1 ) and with 3 strong generators
generator 0:
1 0 0 
0 0 1 
0 1 0 

generator 1:
0 1 0 
1 0 0 
0 0 1 

generator 2:
0 0 1 
0 1 0 
1 0 0 

>>>>G order before6>>>>G order after6Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )_{6}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : { 0, 1, 2, 4 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : { 0, 1, 2, 4 }
generator matrix:
1 0 0 1 
0 1 0 1 
0 0 1 0 
(orbit length = 3)
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : { 0, 1, 2, 4 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=4,orblen3,go_G6,go_HNULL
oracle::init_extension_node_prepare_H
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )oracle::init_extension_node_prepare_H computing stabilizer of point 4 (of index 3 in a group of order 6 = 3 * 2)
verbose_level=4
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )oracle::init_extension_node_prepare_H computing stabilizer of point 4 in group of order 6
Level 3 Node 3 = 0 / 2 Extension 1 / 2 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 3 Node 3 = 0 / 2 Extension 1 / 2 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 6 orbit_len = 3 stab_order = NULL
Level 3 Node 3 = 0 / 2 Extension 1 / 2 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )oracle::init_extension_node_prepare_H point stabilizer has order 2, of index = 3 in 6
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 2, 1, 1 ) and with 1 strong generators
generator 0:
0 1 0 
1 0 0 
0 0 1 

(2)(3)(4)(5, 6)(0, 1)
oracle::init_extension_node_prepare_H done
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : { 0, 1, 2, 4 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )upstep_work::init_extension_node calling upstep
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )upstep_work::init_extension_node calling upstep_for_sets
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : upstep for set { 0, 1, 2, 4 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 4
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=4
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res4
ACTION PGL_3_2_res4 degree=4 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : initializing up_orbit with restricted action ACTION PGL_3_2_res4 degree=4 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : initializing up_orbit with generators
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : computing orbit of point 4
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    0 :    1
   2 :    2 :    2
   3 :    3 :    3
upstep_work::upstep_for_sets coset=0
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 0 / 4 :  we are trying to map 0 to 4
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 0 / 4 :  orbit length upstep so far: 1 checking possible image 0
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 0 / 4 : exchanged set: { 4, 1, 2, 0 }
calling find_automorphism()
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 0 / 4 : ( 4, 1, 2, 0 )
generator matrix:
1 0 0 1 
1 1 0 0 
0 0 1 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/0) extension from 2 to 3
upstep_work::handle_last_level lvl=3 node=3 current_node=3 current_extension=1 pt0=4
oracle::handle_last_level my_current_node=6
upstep_work::handle_last_level: at (3/1) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 0 / 4 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 0 / 4 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 0 / 4 : upstep_work::upstep_for_sets found automorphism mapping 0 to 4
extend_orbit() extending orbit 0 of length 1
schreier::extend_orbit orbit extended to length 3
upstep_work::upstep_for_sets new orbit length upstep = 3
upstep_work::upstep_for_sets coset=1
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 1 / 4 :  we are trying to map 1 to 4
coset 1 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=2
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 2 / 4 :  we are trying to map 2 to 4
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 2 / 4 :  orbit length upstep so far: 3 checking possible image 2
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 2 / 4 : exchanged set: { 0, 1, 4, 2 }
calling find_automorphism()
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 2 / 4 : ( 0, 1, 4, 2 )
generator matrix:
1 0 1 0 
0 1 1 0 
0 0 0 1 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/1) extension from 2 to 4
upstep_work::handle_last_level lvl=3 node=4 current_node=4 current_extension=0 pt0=2
oracle::handle_last_level my_current_node=6
upstep_work::handle_last_level calling install_fusion_node at (4/0)
install fusion node (4/0) -> (3/1)
upstep_work::handle_last_level install_fusion_node at (4/0) done, returning no_result_fusion_node_installed
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 2 / 4 :  returning no_result_fusion_node_installed
upstep_work::upstep_for_sets find_automorphism_by_tracing returns no_result_fusion_node_installed
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : Coset 2 / 4 : upstep_work::upstep_for_sets calling find_automorphism returns no_result_fusion_node_installed
upstep_work::upstep_for_sets no_result_fusion_node_installed
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1, 2, 4 } is 3
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 2, orbit length 3, new group order 6
sims::random_element
sims::random_element orbit_len=( 2, 1, 1 )
sims::random_element
path=( 1, 0, 0 )
sims::element_from_path
path=( 1, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 1 before coset_rep
sims::coset_rep i=0 j=1
sims::coset_rep i=0 j=1
cosetrep:
0 1 0 
1 0 0 
0 0 1 
sims::element_from_path level 0 coset 1 after coset_rep
sims::element_from_path level 0 coset 1:
cosetrep:
0 1 0 
1 0 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 1, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 3 of 6 with 2 strong generators
remaining factor: 2 remainder 0
sims::random_element
sims::random_element orbit_len=( 3, 1, 1 )
sims::random_element
path=( 2, 0, 0 )
sims::element_from_path
path=( 2, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 2 before coset_rep
sims::coset_rep i=0 j=2
sims::coset_rep i=0 j=2
cosetrep:
1 1 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 2 after coset_rep
sims::element_from_path level 0 coset 2:
cosetrep:
1 1 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 2, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 6 of 6 with 3 strong generators
remaining factor: 1 remainder 0
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 3 strong generators
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )extension with point 4 : 
after upstep_for_sets/upstep_subspace_action
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )_{6}
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : ( 0, 1, 2, 4 )_{6} (double check)
upstep_work::init_extension_node done
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : with point 4 : done 
nb_cosets_processed=2
init_extension_node returns TRUE
cur=7
Level 3 Node 3 = 0 / 2 Extension 1 / 2 : with point 4 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=3 prev_ex=1 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 1 / 2:
generator::extend_node after freeing Work
Time 0:00 : Level 3 Node 3 = 0 / 2 :  **** Upstep finished with 2 new orbits and 0 fusion nodes. We now have 2 nodes at level 4, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
    3 :          2 :          1 :          3 :          0
Time 0:00 : Level 3 Node 3 = 0 / 2 :  Upstep : progress: 100. 0 % 
generator::upstep case 1 / 2
Time 0:00 : Level 3 Node 4 = 1 / 2 :  Upstep : 
generator::extend_node prev=4 cur=7
Time 0:00 : Level 3 Node 4 = 1 / 2 :  extending set { 0, 1, 4 }_{3 * 2 * 4 = 24} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 1 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 1:
upstep_work::init size=3 prev=4 prev_ex=0 cur=7
upstep_work::init path: ( 0, 1, 2, 4 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=4 prev_ex=0
Level 3 Node 4 = 1 / 2 Extension 0 / 1 : type         fusion
upstep_work::handle_extension fusion type
upstep_work::handle_extension_fusion_type
Level 3 Node 4 = 1 / 2 Extension 0 / 1 :  point 2 { 0, 1, 4, 2 } is a fusion node, skipping
upstep_work::handle_extension prev=4 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 1:
generator::extend_node after freeing Work
Time 0:00 : Level 3 Node 4 = 1 / 2 :  **** Upstep finished with 0 new orbits and 1 fusion nodes. We now have 2 nodes at level 4, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
    3 :          2 :          1 :          3 :          0
Time 0:00 : Level 3 Node 4 = 1 / 2 :  Upstep : progress: 100. 0 % 
generator::extend_level after upstep
generator::housekeeping verbose_level=19
##################################################################################################
Found 2 orbits at depth 4
0 : 1 orbits
1 : 1 orbits
2 : 1 orbits
3 : 2 orbits
4 : 2 orbits
total: 7
(24, 6) average is 15 + 0 / 2
# 4
4 0 1 2 3 24 adaaaaaaafaaaaaaaaaaaaaaabaaaaaaacaaaaaaaeaaaaaaadaaaaaaacaaaaaanbabkbaadjabfeaafhaa
4 0 1 2 4 6 adaaaaaaadaaaaaaaaaaaaaaabaaaaaaacaaaaaaadaaaaaaacaaaaaaabaaaaaabjabakabbdab
-1 2 5 in 0:00
(24, 6) average is 15 + 0 / 2

# in action PGL_3_2
generator_housekeeping not writing files
generator_housekeeping not writing tree
generator::housekeeping done
generator::main:  calling extend_level 4
we will store schreier vectors for this level
##################################################################################################

generator::extend_level constructing nodes at depth 5
verbose_level=18
generator::extend_level 4 calling downstep
##################################################################################################

downstep depth 4 verbose_level=17
Time 0:00 : Level 4 Node 5 = 0 / 2 :  Downstep node starting
oracle::downstep
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : Downstep for { 0, 1, 2, 3 }_{4 * 3 * 2 = 24} verbose_level=15
{ 0, 1, 2, 3 }_{4 * 3 * 2 = 24}
generator matrix:
1 0 0 1 
0 1 0 1 
0 0 1 1 
oracle::downstep before downstep_orbits
Time 0:00 : Level 4 Node 5 = 0 / 2 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 4 Node 5 = 0 / 2 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0, 1, 2, 3 ) testing 7 candidates
check_mindist_early_test_func for { 0, 1, 2, 3 }_{4 * 3 * 2 = 24}
after Schreier.compute_all_orbits_on_invariant_subset, we found 2 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3, 0 }

1 0 0 1 1 
0 1 0 1 0 
0 0 1 1 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3, 4 }

1 0 0 1 1 
0 1 0 1 1 
0 0 1 1 0 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 2 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 5
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 4 total length 4 degree=7
schreier::compute_all_point_orbits pt = 4 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 4 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 4
found orbit of length 3 total length 7 degree=7
schreier::compute_all_point_orbits found 2 orbits
The distribution of orbit lengths is: ( 3, 4 )
Time 0:00 : Level 4 Node 5 = 0 / 2 : The 2 orbits are:
   0 :     4 :     0 : ( 0, 1, 2, 3 )
   1 :     3 :     4 : ( 4, 5, 6 )
Time 0:00 : Level 4 Node 5 = 0 / 2 : oracle::downstep_orbits: we found 2 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 4 Node 5 = 0 / 2 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 2 orbits
orbit 0 of point 0 of length 4 is accepted as orbit 0
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 1 of point 4 of length 3 is accepted as orbit 1
check_orbits: orbit testing finished: 2 orbits out of 2 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     4
    1 :     4 :     3
the stabilizer has 2 good orbits with 7 points
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : after check_orbits_wrapper:
nb_good_orbits=2
nb_points=7
Time 0:00 : Level 4 Node 5 = 0 / 2 : The 2 orbits are:
   0 :     4 :     0 : ( 0, 1, 2, 3 )
   1 :     3 :     4 : ( 4, 5, 6 )
calling get_schreier_vector
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     2 :     1
    2 :     2 :     0 :     3
    3 :     3 :     0 :     4
    4 :     4 :    -1 :    -1
    5 :     5 :     4 :     1
    6 :     6 :     4 :     2
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     2 :     1
    2 :     2 :     0 :     3
    3 :     3 :     0 :     4
    4 :     4 :    -1 :    -1
    5 :     5 :     4 :     1
    6 :     6 :     4 :     2
oracle::relabel_schreier_vector done
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 4 Node 5 = 0 / 2 : oracle::downstep_implicit_fusion
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 2 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : after test_orbits and find_extensions, we have 1 extensions
oracle::print_extensions node=5 at depth 4 degree=7
Node 5, the extensions are
i : pt : orbit_len : type : to where
    0 :       4 :     3 :    unprocessed    0
done with node 5
Time 0:00 : Level 4 Node 5 = 0 / 2 :  : found 1 extensions (out of 2 orbits) with 3 points 
oracle::downstep done

Downstep node finished :  found 7 live points in 1 orbits : oracle::print_extensions node=5 at depth 4 degree=7
Node 5, the extensions are
i : pt : orbit_len : type : to where
    0 :       4 :     3 :    unprocessed    0
done with node 5
progress: 0. 0 % 
oracle::downstep
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : Downstep for { 0, 1, 2, 4 }_{3 * 2 * 1 = 6} verbose_level=15
{ 0, 1, 2, 4 }_{3 * 2 * 1 = 6}
generator matrix:
1 0 0 1 
0 1 0 1 
0 0 1 0 
oracle::downstep before downstep_orbits
Time 0:00 : Level 4 Node 6 = 1 / 2 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 4 Node 6 = 1 / 2 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0, 1, 2, 4 ) testing 7 candidates
check_mindist_early_test_func for { 0, 1, 2, 4 }_{3 * 2 * 1 = 6}
after Schreier.compute_all_orbits_on_invariant_subset, we found 3 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 4, 0 }

1 0 0 1 1 
0 1 0 1 0 
0 0 1 0 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 4, 2 }

1 0 0 1 0 
0 1 0 1 0 
0 0 1 0 1 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 4, 3 }

1 0 0 1 1 
0 1 0 1 1 
0 0 1 0 1 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 3 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 3
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 3 total length 3 degree=7
schreier::compute_all_point_orbits pt = 2 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 2 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 2
found orbit of length 1 total length 4 degree=7
schreier::compute_all_point_orbits pt = 3 / 7 nb_orbits=2 computing orbit
schreier::compute_point_orbit computing orbit of point 3 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 3
found orbit of length 3 total length 7 degree=7
schreier::compute_all_point_orbits found 3 orbits
The distribution of orbit lengths is: ( 1, 3^2 )
Time 0:00 : Level 4 Node 6 = 1 / 2 : The 3 orbits are:
   0 :     3 :     0 : ( 0, 1, 4 )
   1 :     1 :     2 : ( 2 )
   2 :     3 :     3 : ( 3, 5, 6 )
Time 0:00 : Level 4 Node 6 = 1 / 2 : oracle::downstep_orbits: we found 3 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 4 Node 6 = 1 / 2 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 3 orbits
orbit 0 of point 0 of length 3 is accepted as orbit 0
orbit 1 of point 2 of length 1 is accepted as orbit 1
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 2 of point 3 of length 3 is accepted as orbit 2
check_orbits: orbit testing finished: 3 orbits out of 3 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     3
    1 :     2 :     1
    2 :     3 :     3
the stabilizer has 3 good orbits with 7 points
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : after check_orbits_wrapper:
nb_good_orbits=3
nb_points=7
Time 0:00 : Level 4 Node 6 = 1 / 2 : The 3 orbits are:
   0 :     3 :     0 : ( 0, 1, 4 )
   1 :     1 :     2 : ( 2 )
   2 :     3 :     3 : ( 3, 5, 6 )
calling get_schreier_vector
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     1
    2 :     2 :    -1 :    -1
    3 :     3 :    -1 :    -1
    4 :     4 :     0 :     2
    5 :     5 :     3 :     2
    6 :     6 :     3 :     0
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     0 :     1
    2 :     2 :    -1 :    -1
    3 :     3 :    -1 :    -1
    4 :     4 :     0 :     2
    5 :     5 :     3 :     2
    6 :     6 :     3 :     0
oracle::relabel_schreier_vector done
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 4 Node 6 = 1 / 2 : oracle::downstep_implicit_fusion
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 3 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : after test_orbits and find_extensions, we have 1 extensions
oracle::print_extensions node=6 at depth 4 degree=7
Node 6, the extensions are
i : pt : orbit_len : type : to where
    0 :       3 :     3 :    unprocessed    0
done with node 6
Time 0:00 : Level 4 Node 6 = 1 / 2 :  : found 1 extensions (out of 3 orbits) with 3 points 
oracle::downstep done
generator::extend_level after downstep
generator::extend_level calling upstep
generator::upstep
verbose_level = 17
##################################################################################################

extension step depth 4
verbose_level=17
f_indicate_not_canonicals=0
with 2 extension nodes
generator::upstep case 0 / 2
Time 0:00 : Level 4 Node 5 = 0 / 2 :  Upstep : 
generator::extend_node prev=5 cur=7
Time 0:00 : Level 4 Node 5 = 0 / 2 :  extending set { 0, 1, 2, 3 }_{4 * 3 * 2 = 24} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 1 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 1:
upstep_work::init size=4 prev=5 prev_ex=0 cur=7
upstep_work::init path: ( 0, 1, 2, 3, 5 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=5 prev_ex=0
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : with point 4 : 
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : with point 4 : before init_extension_node
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : upstep_work::init_extension_node cur=7 verbose_level=8
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : upstep_work::init_extension_node initializing Node 7 ( 0, 1, 2, 3, 4 ) f_indicate_not_canonicals=0 verbose_level=8
point 4 lies in an orbit of length 3 verbose_level = 8
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : { 0, 1, 2, 3, 4 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 19, 20, 21, 22, 23 )
verbose_level=4
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 5 strong generators
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 4, 3, 2 ) and with 5 strong generators
generator 0:
1 0 0 
0 1 0 
1 1 1 

generator 1:
1 0 0 
0 0 1 
0 1 0 

generator 2:
1 0 0 
1 1 1 
0 0 1 

generator 3:
0 0 1 
0 1 0 
1 0 0 

generator 4:
1 1 1 
0 1 0 
1 0 0 

>>>>G order before24>>>>G order after24Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )_{24}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : { 0, 1, 2, 3, 4 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : { 0, 1, 2, 3, 4 }
generator matrix:
1 0 0 1 1 
0 1 0 1 1 
0 0 1 1 0 
(orbit length = 3)
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : { 0, 1, 2, 3, 4 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=4,orblen3,go_G24,go_HNULL
oracle::init_extension_node_prepare_H
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )oracle::init_extension_node_prepare_H computing stabilizer of point 4 (of index 3 in a group of order 24 = 4 * 3 * 2)
verbose_level=4
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )oracle::init_extension_node_prepare_H computing stabilizer of point 4 in group of order 24
Level 4 Node 5 = 0 / 2 Extension 0 / 1 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 4 Node 5 = 0 / 2 Extension 0 / 1 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 24 orbit_len = 3 stab_order = NULL
Level 4 Node 5 = 0 / 2 Extension 0 / 1 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )oracle::init_extension_node_prepare_H point stabilizer has order 8, of index = 3 in 24
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 4, 1, 2 ) and with 2 strong generators
generator 0:
1 0 0 
0 1 0 
1 1 1 

(0)(1)(4)(2, 3)(5, 6)
generator 1:
0 0 1 
1 1 1 
1 0 0 

(6)(4)(5)(1, 3)(0, 2)
oracle::init_extension_node_prepare_H done
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : { 0, 1, 2, 3, 4 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )upstep_work::init_extension_node calling upstep
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )upstep_work::init_extension_node calling upstep_for_sets
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : upstep for set { 0, 1, 2, 3, 4 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 5
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=5
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res5
ACTION PGL_3_2_res5 degree=5 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : initializing up_orbit with restricted action ACTION PGL_3_2_res5 degree=5 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : initializing up_orbit with generators
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : computing orbit of point 4
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    0 :    1
   2 :    0 :    2
   3 :    0 :    3
   4 :    4 :    4
upstep_work::upstep_for_sets coset=0
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 0 / 5 :  we are trying to map 0 to 4
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 0 / 5 :  orbit length upstep so far: 1 checking possible image 0
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 0 / 5 : exchanged set: { 4, 1, 2, 3, 0 }
calling find_automorphism()
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 0 / 5 : ( 4, 1, 2, 3, 0 )
generator matrix:
1 0 0 1 1 
1 1 0 1 0 
0 0 1 1 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/0) extension from 2 to 3
upstep_work::find_automorphism_by_tracing_recursion at (3/1) extension from 3 to 6
upstep_work::handle_last_level lvl=4 node=6 current_node=6 current_extension=0 pt0=3
oracle::handle_last_level my_current_node=7
upstep_work::handle_last_level calling install_fusion_node at (6/0)
install fusion node (6/0) -> (5/0)
upstep_work::handle_last_level install_fusion_node at (6/0) done, returning no_result_fusion_node_installed
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 0 / 5 :  returning no_result_fusion_node_installed
upstep_work::upstep_for_sets find_automorphism_by_tracing returns no_result_fusion_node_installed
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 0 / 5 : upstep_work::upstep_for_sets calling find_automorphism returns no_result_fusion_node_installed
upstep_work::upstep_for_sets no_result_fusion_node_installed
upstep_work::upstep_for_sets coset=1
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 1 / 5 :  we are trying to map 1 to 4
coset 1 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=2
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 2 / 5 :  we are trying to map 2 to 4
coset 2 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=3
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : Coset 3 / 5 :  we are trying to map 3 to 4
coset 3 is at 0 which has already been done, so we save one trace
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1, 2, 3, 4 } is 1
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 8, orbit length 1, new group order 8
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 2 strong generators
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )extension with point 4 : 
after upstep_for_sets/upstep_subspace_action
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )_{8}
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : ( 0, 1, 2, 3, 4 )_{8} (double check)
upstep_work::init_extension_node done
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : with point 4 : done 
nb_cosets_processed=1
init_extension_node returns TRUE
cur=8
Level 4 Node 5 = 0 / 2 Extension 0 / 1 : with point 4 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=5 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 1:
generator::extend_node after freeing Work
Time 0:00 : Level 4 Node 5 = 0 / 2 :  **** Upstep finished with 1 new orbits and 0 fusion nodes. We now have 1 nodes at level 5, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
    3 :          2 :          1 :          3 :          0
    4 :          1 :          1 :          2 :          0
Time 0:00 : Level 4 Node 5 = 0 / 2 :  Upstep : progress: 100. 0 % 
generator::upstep case 1 / 2
Time 0:00 : Level 4 Node 6 = 1 / 2 :  Upstep : 
generator::extend_node prev=6 cur=8
Time 0:00 : Level 4 Node 6 = 1 / 2 :  extending set { 0, 1, 2, 4 }_{3 * 2 * 1 = 6} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 1 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 1:
upstep_work::init size=4 prev=6 prev_ex=0 cur=8
upstep_work::init path: ( 0, 1, 2, 3, 6 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=6 prev_ex=0
Level 4 Node 6 = 1 / 2 Extension 0 / 1 : type         fusion
upstep_work::handle_extension fusion type
upstep_work::handle_extension_fusion_type
Level 4 Node 6 = 1 / 2 Extension 0 / 1 :  point 3 { 0, 1, 2, 4, 3 } is a fusion node, skipping
upstep_work::handle_extension prev=6 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 1:
generator::extend_node after freeing Work
Time 0:00 : Level 4 Node 6 = 1 / 2 :  **** Upstep finished with 0 new orbits and 1 fusion nodes. We now have 1 nodes at level 5, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
    3 :          2 :          1 :          3 :          0
    4 :          1 :          1 :          2 :          0
Time 0:00 : Level 4 Node 6 = 1 / 2 :  Upstep : progress: 100. 0 % 
generator::extend_level after upstep
generator::housekeeping verbose_level=19
##################################################################################################
Found 1 orbits at depth 5
0 : 1 orbits
1 : 1 orbits
2 : 1 orbits
3 : 2 orbits
4 : 2 orbits
5 : 1 orbits
total: 8
(8) average is 8 + 0 / 1
# 5
5 0 1 2 3 4 8 adaaaaaaacaaaaaaaaaaaaaaabaaaaaaacaaaaaaaeaaaaaaabaaaaaaacaaaaaanbabhmaa
-1 1 7 in 0:00
(8) average is 8 + 0 / 1

# in action PGL_3_2
generator_housekeeping not writing files
generator_housekeeping not writing tree
generator::housekeeping done
generator::main:  calling extend_level 5
we will store schreier vectors for this level
##################################################################################################

generator::extend_level constructing nodes at depth 6
verbose_level=18
generator::extend_level 5 calling downstep
##################################################################################################

downstep depth 5 verbose_level=17
Time 0:00 : Level 5 Node 7 = 0 / 1 :  Downstep node starting
oracle::downstep
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : Downstep for { 0, 1, 2, 3, 4 }_{4 * 1 * 2 = 8} verbose_level=15
{ 0, 1, 2, 3, 4 }_{4 * 1 * 2 = 8}
generator matrix:
1 0 0 1 1 
0 1 0 1 1 
0 0 1 1 0 
oracle::downstep before downstep_orbits
Time 0:00 : Level 5 Node 7 = 0 / 1 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 5 Node 7 = 0 / 1 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0, 1, 2, 3, 4 ) testing 7 candidates
check_mindist_early_test_func for { 0, 1, 2, 3, 4 }_{4 * 1 * 2 = 8}
after Schreier.compute_all_orbits_on_invariant_subset, we found 3 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3, 4, 0 }

1 0 0 1 1 1 
0 1 0 1 1 0 
0 0 1 1 0 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3, 4, 4 }

1 0 0 1 1 1 
0 1 0 1 1 1 
0 0 1 1 0 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3, 4, 5 }

1 0 0 1 1 1 
0 1 0 1 1 0 
0 0 1 1 0 1 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 3 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 2
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 4 total length 4 degree=7
schreier::compute_all_point_orbits pt = 4 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 4 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 4
found orbit of length 1 total length 5 degree=7
schreier::compute_all_point_orbits pt = 5 / 7 nb_orbits=2 computing orbit
schreier::compute_point_orbit computing orbit of point 5 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 5
found orbit of length 2 total length 7 degree=7
schreier::compute_all_point_orbits found 3 orbits
The distribution of orbit lengths is: ( 1, 2, 4 )
Time 0:00 : Level 5 Node 7 = 0 / 1 : The 3 orbits are:
   0 :     4 :     0 : ( 0, 1, 2, 3 )
   1 :     1 :     4 : ( 4 )
   2 :     2 :     5 : ( 5, 6 )
Time 0:00 : Level 5 Node 7 = 0 / 1 : oracle::downstep_orbits: we found 3 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 5 Node 7 = 0 / 1 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 3 orbits
orbit 0 of point 0 of length 4 is accepted as orbit 0
orbit 1 of point 4 of length 1 is accepted as orbit 1
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 2 of point 5 of length 2 is accepted as orbit 2
check_orbits: orbit testing finished: 3 orbits out of 3 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     4
    1 :     4 :     1
    2 :     5 :     2
the stabilizer has 3 good orbits with 7 points
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : after check_orbits_wrapper:
nb_good_orbits=3
nb_points=7
Time 0:00 : Level 5 Node 7 = 0 / 1 : The 3 orbits are:
   0 :     4 :     0 : ( 0, 1, 2, 3 )
   1 :     1 :     4 : ( 4 )
   2 :     2 :     5 : ( 5, 6 )
calling get_schreier_vector
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     3 :     1
    2 :     2 :     0 :     1
    3 :     3 :     2 :     0
    4 :     4 :    -1 :    -1
    5 :     5 :    -1 :    -1
    6 :     6 :     5 :     0
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     3 :     1
    2 :     2 :     0 :     1
    3 :     3 :     2 :     0
    4 :     4 :    -1 :    -1
    5 :     5 :    -1 :    -1
    6 :     6 :     5 :     0
oracle::relabel_schreier_vector done
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 5 Node 7 = 0 / 1 : oracle::downstep_implicit_fusion
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 3 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : after test_orbits and find_extensions, we have 1 extensions
oracle::print_extensions node=7 at depth 5 degree=7
Node 7, the extensions are
i : pt : orbit_len : type : to where
    0 :       5 :     2 :    unprocessed    0
done with node 7
Time 0:00 : Level 5 Node 7 = 0 / 1 :  : found 1 extensions (out of 3 orbits) with 2 points 
oracle::downstep done

Downstep node finished :  found 7 live points in 1 orbits : oracle::print_extensions node=7 at depth 5 degree=7
Node 7, the extensions are
i : pt : orbit_len : type : to where
    0 :       5 :     2 :    unprocessed    0
done with node 7
progress: 0. 0 % 
generator::extend_level after downstep
generator::extend_level calling upstep
generator::upstep
verbose_level = 17
##################################################################################################

extension step depth 5
verbose_level=17
f_indicate_not_canonicals=0
with 1 extension nodes
generator::upstep case 0 / 1
Time 0:00 : Level 5 Node 7 = 0 / 1 :  Upstep : 
generator::extend_node prev=7 cur=8
Time 0:00 : Level 5 Node 7 = 0 / 1 :  extending set { 0, 1, 2, 3, 4 }_{4 * 1 * 2 = 8} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 1 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 1:
upstep_work::init size=5 prev=7 prev_ex=0 cur=8
upstep_work::init path: ( 0, 1, 2, 3, 5, 7 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=7 prev_ex=0
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : with point 5 : 
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : with point 5 : before init_extension_node
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node cur=8 verbose_level=8
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node initializing Node 8 ( 0, 1, 2, 3, 4, 5 ) f_indicate_not_canonicals=0 verbose_level=8
point 5 lies in an orbit of length 2 verbose_level = 8
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 29, 30 )
verbose_level=4
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 2 strong generators
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 4, 1, 2 ) and with 2 strong generators
generator 0:
1 0 0 
0 1 0 
1 1 1 

generator 1:
0 0 1 
1 1 1 
1 0 0 

>>>>G order before8>>>>G order after8Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )_{8}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5 }
generator matrix:
1 0 0 1 1 1 
0 1 0 1 1 0 
0 0 1 1 0 1 
(orbit length = 2)
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=5,orblen2,go_G8,go_HNULL
oracle::init_extension_node_prepare_H
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )oracle::init_extension_node_prepare_H computing stabilizer of point 5 (of index 2 in a group of order 8 = 4 * 1 * 2)
verbose_level=4
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )oracle::init_extension_node_prepare_H computing stabilizer of point 5 in group of order 8
Level 5 Node 7 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 5 Node 7 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 8 orbit_len = 2 stab_order = NULL
Level 5 Node 7 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )oracle::init_extension_node_prepare_H point stabilizer has order 4, of index = 2 in 8
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 4, 1, 1 ) and with 2 strong generators
generator 0:
0 0 1 
1 1 1 
1 0 0 

(6)(4)(5)(1, 3)(0, 2)
generator 1:
1 1 1 
0 0 1 
0 1 0 

(6)(4)(5)(1, 2)(0, 3)
oracle::init_extension_node_prepare_H done
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )upstep_work::init_extension_node calling upstep
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )upstep_work::init_extension_node calling upstep_for_sets
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : upstep for set { 0, 1, 2, 3, 4, 5 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 6
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=6
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res6
ACTION PGL_3_2_res6 degree=6 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : initializing up_orbit with restricted action ACTION PGL_3_2_res6 degree=6 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : initializing up_orbit with generators
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : computing orbit of point 5
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    0 :    1
   2 :    0 :    2
   3 :    0 :    3
   4 :    4 :    4
   5 :    5 :    5
upstep_work::upstep_for_sets coset=0
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 0 / 6 :  we are trying to map 0 to 5
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 0 / 6 :  orbit length upstep so far: 1 checking possible image 0
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 0 / 6 : exchanged set: { 5, 1, 2, 3, 4, 0 }
calling find_automorphism()
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 0 / 6 : ( 5, 1, 2, 3, 4, 0 )
generator matrix:
1 0 0 1 1 1 
0 1 0 1 1 0 
1 0 1 1 0 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/0) extension from 2 to 3
upstep_work::find_automorphism_by_tracing_recursion at (3/1) extension from 3 to 6
upstep_work::find_automorphism_by_tracing_recursion lvl 4 at (6/0) fusion from 6 to 7
upstep_work::handle_last_level lvl=5 node=7 current_node=7 current_extension=0 pt0=5
oracle::handle_last_level my_current_node=8
upstep_work::handle_last_level: at (7/0) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 0 / 6 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 0 / 6 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 0 / 6 : upstep_work::upstep_for_sets found automorphism mapping 0 to 5
extend_orbit() extending orbit 0 of length 1
schreier::extend_orbit orbit extended to length 6
upstep_work::upstep_for_sets new orbit length upstep = 6
upstep_work::upstep_for_sets coset=1
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 1 / 6 :  we are trying to map 1 to 5
coset 1 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=2
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 2 / 6 :  we are trying to map 2 to 5
coset 2 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=3
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 3 / 6 :  we are trying to map 3 to 5
coset 3 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=4
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : Coset 4 / 6 :  we are trying to map 4 to 5
coset 4 is at 0 which has already been done, so we save one trace
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1, 2, 3, 4, 5 } is 6
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 4, orbit length 6, new group order 24
sims::random_element
sims::random_element orbit_len=( 4, 1, 1 )
sims::random_element
path=( 2, 0, 0 )
sims::element_from_path
path=( 2, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 2 before coset_rep
sims::coset_rep i=0 j=2
sims::coset_rep i=0 j=2
cosetrep:
1 1 1 
0 0 1 
0 1 0 
sims::element_from_path level 0 coset 2 after coset_rep
sims::element_from_path level 0 coset 2:
cosetrep:
1 1 1 
0 0 1 
0 1 0 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 2, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 6 of 24 with 3 strong generators
remaining factor: 4 remainder 0
sims::random_element
sims::random_element orbit_len=( 6, 1, 1 )
sims::random_element
path=( 5, 0, 0 )
sims::element_from_path
path=( 5, 0, 0 )
A->degree=7
sims::element_from_path level 0 coset 5 before coset_rep
sims::coset_rep i=0 j=5
sims::coset_rep i=0 j=5
cosetrep:
1 1 0 
1 0 0 
1 1 1 
sims::element_from_path level 0 coset 5 after coset_rep
sims::element_from_path level 0 coset 5:
cosetrep:
1 1 0 
1 0 0 
1 1 1 

sims::element_from_path level 1 coset 0 before coset_rep
sims::coset_rep i=1 j=0
sims::coset_rep i=1 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 1 coset 0 after coset_rep
sims::element_from_path level 1 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 5, 0, 0 }
sims::transitive_extension_tolerant found an extension of order 12 of 24 with 4 strong generators
remaining factor: 2 remainder 0
sims::random_element
sims::random_element orbit_len=( 6, 2, 1 )
sims::random_element
path=( 3, 1, 0 )
sims::element_from_path
path=( 3, 1, 0 )
A->degree=7
sims::element_from_path level 0 coset 3 before coset_rep
sims::coset_rep i=0 j=3
sims::coset_rep i=0 j=3
cosetrep:
0 1 0 
1 0 0 
1 1 1 
sims::element_from_path level 0 coset 3 after coset_rep
sims::element_from_path level 0 coset 3:
cosetrep:
0 1 0 
1 0 0 
1 1 1 

sims::element_from_path level 1 coset 1 before coset_rep
sims::coset_rep i=1 j=1
sims::coset_rep i=1 j=1
cosetrep:
1 0 0 
1 1 0 
1 0 1 
sims::element_from_path level 1 coset 1 after coset_rep
sims::element_from_path level 1 coset 1:
cosetrep:
1 0 0 
1 1 0 
1 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 2, random element { 3, 1, 0 }
sims::transitive_extension_tolerant found an extension of order 24 of 24 with 5 strong generators
remaining factor: 1 remainder 0
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 5 strong generators
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )extension with point 5 : 
after upstep_for_sets/upstep_subspace_action
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )_{24}
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5 )_{24} (double check)
upstep_work::init_extension_node done
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : with point 5 : done 
nb_cosets_processed=1
init_extension_node returns TRUE
cur=9
Level 5 Node 7 = 0 / 1 Extension 0 / 1 : with point 5 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=7 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 1:
generator::extend_node after freeing Work
Time 0:00 : Level 5 Node 7 = 0 / 1 :  **** Upstep finished with 1 new orbits and 0 fusion nodes. We now have 1 nodes at level 6, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
    3 :          2 :          1 :          3 :          0
    4 :          1 :          1 :          2 :          0
    5 :          1 :          0 :          1 :          0
Time 0:00 : Level 5 Node 7 = 0 / 1 :  Upstep : progress: 100. 0 % 
generator::extend_level after upstep
generator::housekeeping verbose_level=19
##################################################################################################
Found 1 orbits at depth 6
0 : 1 orbits
1 : 1 orbits
2 : 1 orbits
3 : 2 orbits
4 : 2 orbits
5 : 1 orbits
6 : 1 orbits
total: 9
(24) average is 24 + 0 / 1
# 6
6 0 1 2 3 4 5 24 adaaaaaaafaaaaaaaaaaaaaaabaaaaaaacaaaaaaagaaaaaaaeaaaaaaabaaaaaafjabkbaahmaakhaahnaa
-1 1 8 in 0:00
(24) average is 24 + 0 / 1

# in action PGL_3_2
generator_housekeeping not writing files
generator_housekeeping not writing tree
generator::housekeeping done
generator::main:  calling extend_level 6
we will store schreier vectors for this level
##################################################################################################

generator::extend_level constructing nodes at depth 7
verbose_level=18
generator::extend_level 6 calling downstep
##################################################################################################

downstep depth 6 verbose_level=17
Time 0:00 : Level 6 Node 8 = 0 / 1 :  Downstep node starting
oracle::downstep
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : Downstep for { 0, 1, 2, 3, 4, 5 }_{6 * 4 * 1 = 24} verbose_level=15
{ 0, 1, 2, 3, 4, 5 }_{6 * 4 * 1 = 24}
generator matrix:
1 0 0 1 1 1 
0 1 0 1 1 0 
0 0 1 1 0 1 
oracle::downstep before downstep_orbits
Time 0:00 : Level 6 Node 8 = 0 / 1 : oracle::downstep_orbits
verbose_level=14
oracle::downstep_get_invariant_subset
Time 0:00 : Level 6 Node 8 = 0 / 1 : oracle::downstep_get_invariant_subset Getting live points from previous level
oracle::downstep_get_invariant_subset done
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : live points at the predecessor node: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : downstep_apply_early_test number of live points = 7
calling early_test_func
check_mindist_early_test_func S=( 0, 1, 2, 3, 4, 5 ) testing 7 candidates
check_mindist_early_test_func for { 0, 1, 2, 3, 4, 5 }_{6 * 4 * 1 = 24}
after Schreier.compute_all_orbits_on_invariant_subset, we found 2 orbits
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3, 4, 5, 0 }

1 0 0 1 1 1 1 
0 1 0 1 1 0 0 
0 0 1 1 0 1 0 
rank_checker::check_rank_last_two_are_fixed: checking the set { 0, 1, 2, 3, 4, 5, 6 }

1 0 0 1 1 1 0 
0 1 0 1 1 0 1 
0 0 1 1 0 1 1 
after Schreier.compute_all_orbits_on_invariant_subset, we found 7 good candidates in 2 good orbits
check_mindist_early_test_func nb_good_candidates=7
oracle::downstep_apply_early_test nb_candidates=7
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : live points after downstep_apply_early_test: number=7 : ( 0, 1, 2, 3, 4, 5, 6 )
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 12
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
created action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
schreier::init_generators_by_hdl
nb_gen = 5
degree = 7
schreier::init_generators_by_hdl before init_images()
schreier::init_images
schreier::init_images done
schreier::init_generators_by_hdl done
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : calling Schreier.compute_all_point_orbits for a set of size 7
schreier::compute_all_point_orbits
schreier::compute_all_point_orbits pt = 0 / 7 nb_orbits=0 computing orbit
schreier::compute_point_orbit computing orbit of point 0 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 0
found orbit of length 6 total length 6 degree=7
schreier::compute_all_point_orbits pt = 6 / 7 nb_orbits=1 computing orbit
schreier::compute_point_orbit computing orbit of point 6 in action PGL_3_2_res7
schreier::compute_point_orbit computing orbit of pt 6
found orbit of length 1 total length 7 degree=7
schreier::compute_all_point_orbits found 2 orbits
The distribution of orbit lengths is: ( 1, 6 )
Time 0:00 : Level 6 Node 8 = 0 / 1 : The 2 orbits are:
   0 :     6 :     0 : ( 0, 1, 2, 3, 4, 5 )
   1 :     1 :     6 : ( 6 )
Time 0:00 : Level 6 Node 8 = 0 / 1 : oracle::downstep_orbits: we found 2 orbits
oracle::downstep after downstep_orbits
oracle::downstep before downstep_orbit_test_and_schreier_vector
Time 0:00 : Level 6 Node 8 = 0 / 1 : oracle::downstep_orbit_test_and_schreier_vector
oracle::check_orbits_wrapper calling check_orbits f_use_incremental_test_func_if_available=1
oracle::check_orbits
f_use_incremental_test_func_if_available=1
f_using_invariant_subset=1
check_orbits: testing 2 orbits
orbit 0 of point 0 of length 6 is accepted as orbit 0
oracle::check_orbits calling test_point_using_check_functions
oracle::test_point_using_check_functions
verbose_level=6
orbit 1 of point 6 of length 1 is accepted as orbit 1
check_orbits: orbit testing finished: 2 orbits out of 2 accepted
the good orbits are:
i : representative : orbit length
    0 :     0 :     6
    1 :     6 :     1
the stabilizer has 2 good orbits with 7 points
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : after check_orbits_wrapper:
nb_good_orbits=2
nb_points=7
Time 0:00 : Level 6 Node 8 = 0 / 1 : The 2 orbits are:
   0 :     6 :     0 : ( 0, 1, 2, 3, 4, 5 )
   1 :     1 :     6 : ( 6 )
calling get_schreier_vector
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : after creating Schreier vector.
oracle::relabel_schreier_vector
verbose_level=13
oracle::relabel_schreier_vector sv before:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     2 :     1
    2 :     2 :     0 :     2
    3 :     3 :     0 :     3
    4 :     4 :     3 :     4
    5 :     5 :     0 :     4
    6 :     6 :    -1 :    -1
oracle::relabel_schreier_vector sv after:
schreier vector of length 7:
    0 :     0 :    -1 :    -1
    1 :     1 :     2 :     1
    2 :     2 :     0 :     2
    3 :     3 :     0 :     3
    4 :     4 :     3 :     4
    5 :     5 :     0 :     4
    6 :     6 :    -1 :    -1
oracle::relabel_schreier_vector done
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : after relabeling Schreier vector.
oracle::downstep after downstep_orbit_test_and_schreier_vector
oracle::downstep before downstep_implicit_fusion
Time 0:00 : Level 6 Node 8 = 0 / 1 : oracle::downstep_implicit_fusion
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : no implicit fusion
oracle::downstep after downstep_implicit_fusion
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : calling find_extensions
oracle::downstep before find_extensions
oracle::find_extensions computing all possible extensions (out of 2 orbits)
oracle::downstep after find_extensions
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : after test_orbits and find_extensions, we have 1 extensions
oracle::print_extensions node=8 at depth 6 degree=7
Node 8, the extensions are
i : pt : orbit_len : type : to where
    0 :       6 :     1 :    unprocessed    0
done with node 8
Time 0:00 : Level 6 Node 8 = 0 / 1 :  : found 1 extensions (out of 2 orbits) with 1 points 
oracle::downstep done

Downstep node finished :  found 7 live points in 1 orbits : oracle::print_extensions node=8 at depth 6 degree=7
Node 8, the extensions are
i : pt : orbit_len : type : to where
    0 :       6 :     1 :    unprocessed    0
done with node 8
progress: 0. 0 % 
generator::extend_level after downstep
generator::extend_level calling upstep
generator::upstep
verbose_level = 17
##################################################################################################

extension step depth 6
verbose_level=17
f_indicate_not_canonicals=0
with 1 extension nodes
generator::upstep case 0 / 1
Time 0:00 : Level 6 Node 8 = 0 / 1 :  Upstep : 
generator::extend_node prev=8 cur=9
Time 0:00 : Level 6 Node 8 = 0 / 1 :  extending set { 0, 1, 2, 3, 4, 5 }_{6 * 4 * 1 = 24} with 7 live points : ( 0, 1, 2, 3, 4, 5, 6 )
 with 1 extensions
 verbose_level=15
generator::extend_node working on extension 0 / 1:
upstep_work::init size=6 prev=8 prev_ex=0 cur=9
upstep_work::init path: ( 0, 1, 2, 3, 5, 7, 8 )
upstep_work::init done
upstep_work::handle_extension verbose_level = 11
prev=8 prev_ex=0
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : type    unprocessed
upstep_work::handle_extension unprocessed type
upstep_work::handle_extension_unprocessed_type
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : with point 6 : 
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : with point 6 : before init_extension_node
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node cur=9 verbose_level=8
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : upstep_work::init_extension_node initializing Node 9 ( 0, 1, 2, 3, 4, 5, 6 ) f_indicate_not_canonicals=0 verbose_level=8
point 6 lies in an orbit of length 1 verbose_level = 8
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5, 6 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_G
oracle::init_extension_node_prepare_G
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )oracle::init_extension_node_prepare_G calling init_strong_generators_by_hdl
( 31, 32, 33, 34, 35 )
verbose_level=4
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )oracle::init_extension_node_prepare_G calling schreier_sims for stabilizer with 5 strong generators
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )oracle::init_extension_node_prepare_G the strong generators are:
a group with tl=( 6, 4, 1 ) and with 5 strong generators
generator 0:
1 0 0 
1 1 0 
1 0 1 

generator 1:
1 0 0 
0 0 1 
0 1 0 

generator 2:
0 0 1 
1 1 1 
1 0 0 

generator 3:
1 1 1 
0 0 1 
0 1 0 

generator 4:
1 0 1 
1 1 1 
1 0 0 

>>>>G order before24>>>>G order after24Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )_{24}, previous stabilizer reconstructed
oracle::init_extension_node_prepare_G done
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5, 6 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_G
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5, 6 }
generator matrix:
1 0 0 1 1 1 0 
0 1 0 1 1 0 1 
0 0 1 1 0 1 1 
(orbit length = 1)
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5, 6 }upstep_work::init_extension_node before O_cur->init_extension_node_prepare_H
b4 preping H: pt=6,orblen1,go_G24,go_HNULL
oracle::init_extension_node_prepare_H
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )oracle::init_extension_node_prepare_H computing stabilizer of point 6 (of index 1 in a group of order 24 = 6 * 4)
verbose_level=4
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )oracle::init_extension_node_prepare_H computing stabilizer of point 6 in group of order 24
Level 6 Node 8 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H setting up restricted action from the previous schreier vector:
Level 6 Node 8 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H calling G.point_stabilizer_with_action:
sims:group_order = 24 orbit_len = 1 stab_order = NULL
Level 6 Node 8 = 0 / 1 Extension 0 / 1 :  oracle::init_extension_node_prepare_H G.point_stabilizer_with_action done
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H calling schreier_sims for point stabilizer
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : oracle::init_extension_node_prepare_H after schreier_sims for point stabilizer
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )oracle::init_extension_node_prepare_H point stabilizer has order 24, of index = 1 in 24
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )oracle::init_extension_node_prepare_H point stabilizer is generated by:a group with tl=( 6, 4, 1 ) and with 3 strong generators
generator 0:
1 0 0 
1 1 0 
1 0 1 

(0)(6)(3)(2, 5)(1, 4)
generator 1:
1 0 0 
0 0 1 
0 1 0 

(6)(3)(0)(4, 5)(1, 2)
generator 2:
0 0 1 
1 1 1 
1 0 0 

(6)(4)(5)(1, 3)(0, 2)
oracle::init_extension_node_prepare_H done
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : { 0, 1, 2, 3, 4, 5, 6 }upstep_work::init_extension_node after O_cur->init_extension_node_prepare_H
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )upstep_work::init_extension_node calling upstep
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )upstep_work::init_extension_node calling upstep_for_sets
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : upstep for set { 0, 1, 2, 3, 4, 5, 6 } verbose_level=6 f_indicate_not_canonicals=0
action::induced_action_by_restriction
old_action ACTION PGL_3_2 degree=7 of type matrix_group_t low_level_point_size=3 f_has_sims=1 f_has_strong_generators=1 linear of dimension 3 base: ( 0, 1, 2 ) order 168 = ( 7, 6, 4 )
nb_points = 7
f_induce_action = 0
verbose_level = 4
action_by_restriction::init nb_points=7
action_by_restriction::init finished
action::induced_action_by_restriction finished, created action PGL_3_2_res7
ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : initializing up_orbit with restricted action ACTION PGL_3_2_res7 degree=7 of type action_by_restriction_t->matrix_group_t low_level_point_size=3 f_has_sims=0 f_has_strong_generators=0
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : initializing up_orbit with generators
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : computing orbit of point 6
upstep_work::upstep_for_sets initializing union_find:
upstep_work::upstep_for_sets adding generators to union_find:
upstep_work::upstep_for_sets initializing union_find done
i : ancestor(i) : prev[i]
   0 :    0 :    0
   1 :    1 :    1
   2 :    0 :    2
   3 :    1 :    3
   4 :    1 :    4
   5 :    0 :    5
   6 :    6 :    6
upstep_work::upstep_for_sets coset=0
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 0 / 7 :  we are trying to map 0 to 6
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 0 / 7 :  orbit length upstep so far: 1 checking possible image 0
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 0 / 7 : exchanged set: { 6, 1, 2, 3, 4, 5, 0 }
calling find_automorphism()
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 0 / 7 : ( 6, 1, 2, 3, 4, 5, 0 )
generator matrix:
0 0 0 1 1 1 1 
1 1 0 1 1 0 0 
1 0 1 1 0 1 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/1) extension from 2 to 4
upstep_work::find_automorphism_by_tracing_recursion lvl 3 at (4/0) fusion from 4 to 6
upstep_work::find_automorphism_by_tracing_recursion lvl 4 at (6/0) fusion from 6 to 7
upstep_work::find_automorphism_by_tracing_recursion at (7/0) extension from 7 to 8
upstep_work::handle_last_level lvl=6 node=8 current_node=8 current_extension=0 pt0=6
oracle::handle_last_level my_current_node=9
upstep_work::handle_last_level: at (8/0) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 0 / 7 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 0 / 7 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 0 / 7 : upstep_work::upstep_for_sets found automorphism mapping 0 to 6
extend_orbit() extending orbit 0 of length 1
schreier::extend_orbit orbit extended to length 7
upstep_work::upstep_for_sets new orbit length upstep = 7
upstep_work::upstep_for_sets coset=1
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 1 / 7 :  we are trying to map 1 to 6
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 1 / 7 :  orbit length upstep so far: 7 checking possible image 1
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 1 / 7 : exchanged set: { 0, 6, 2, 3, 4, 5, 1 }
calling find_automorphism()
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 1 / 7 : ( 0, 6, 2, 3, 4, 5, 1 )
generator matrix:
1 0 0 1 1 1 0 
0 1 0 1 1 0 1 
0 1 1 1 0 1 0 
upstep_work::find_automorphism_by_tracing_recursion at (0/0) extension from 0 to 1
upstep_work::find_automorphism_by_tracing_recursion at (1/0) extension from 1 to 2
upstep_work::find_automorphism_by_tracing_recursion at (2/0) extension from 2 to 3
upstep_work::find_automorphism_by_tracing_recursion at (3/1) extension from 3 to 6
upstep_work::find_automorphism_by_tracing_recursion lvl 4 at (6/0) fusion from 6 to 7
upstep_work::find_automorphism_by_tracing_recursion at (7/0) extension from 7 to 8
upstep_work::handle_last_level lvl=6 node=8 current_node=8 current_extension=0 pt0=6
oracle::handle_last_level my_current_node=9
upstep_work::handle_last_level: at (8/0) extension node is current node, i.e. found an automorphism
upstep_work::find_automorphism_by_tracing after find_automorphism_by_tracing_recursion
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 1 / 7 :  returning found_automorphism
upstep_work::upstep_for_sets find_automorphism_by_tracing returns found_automorphism
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 1 / 7 : upstep_work::upstep_for_sets calling find_automorphism returns found_automorphism
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 1 / 7 : upstep_work::upstep_for_sets found automorphism mapping 1 to 6
extend_orbit() extending orbit 0 of length 7
schreier::extend_orbit orbit extended to length 7
upstep_work::upstep_for_sets new orbit length upstep = 7
upstep_work::upstep_for_sets coset=2
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 2 / 7 :  we are trying to map 2 to 6
coset 2 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=3
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 3 / 7 :  we are trying to map 3 to 6
coset 3 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=4
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 4 / 7 :  we are trying to map 4 to 6
coset 4 is at 0 which has already been done, so we save one trace
upstep_work::upstep_for_sets coset=5
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : Coset 5 / 7 :  we are trying to map 5 to 6
coset 5 is at 0 which has already been done, so we save one trace
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : upstep_work::upstep_for_sets upstep orbit length for set { 0, 1, 2, 3, 4, 5, 6 } is 7
sims::transitive_extension_tolerant computing transitive extension
f_tolerant=1
sims::transitive_extension_tolerant group order 24, orbit length 7, new group order 168
sims::random_element
sims::random_element orbit_len=( 6, 4, 1 )
sims::random_element
path=( 1, 1, 0 )
sims::element_from_path
path=( 1, 1, 0 )
A->degree=7
sims::element_from_path level 0 coset 1 before coset_rep
sims::coset_rep i=0 j=1
sims::coset_rep i=0 j=1
cosetrep:
0 0 1 
1 1 1 
1 0 0 
sims::element_from_path level 0 coset 1 after coset_rep
sims::element_from_path level 0 coset 1:
cosetrep:
0 0 1 
1 1 1 
1 0 0 

sims::element_from_path level 1 coset 1 before coset_rep
sims::coset_rep i=1 j=1
sims::coset_rep i=1 j=1
cosetrep:
1 0 0 
1 1 0 
1 0 1 
sims::element_from_path level 1 coset 1 after coset_rep
sims::element_from_path level 1 coset 1:
cosetrep:
1 0 0 
1 1 0 
1 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 5, random element { 1, 1, 0 }
sims::transitive_extension_tolerant found an extension of order 42 of 168 with 4 strong generators
remaining factor: 4 remainder 0
sims::random_element
sims::random_element orbit_len=( 7, 6, 1 )
sims::random_element
path=( 0, 4, 0 )
sims::element_from_path
path=( 0, 4, 0 )
A->degree=7
sims::element_from_path level 0 coset 0 before coset_rep
sims::coset_rep i=0 j=0
sims::coset_rep i=0 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 0 coset 0 after coset_rep
sims::element_from_path level 0 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path level 1 coset 4 before coset_rep
sims::coset_rep i=1 j=4
sims::coset_rep i=1 j=4
cosetrep:
1 0 0 
1 1 1 
1 0 1 
sims::element_from_path level 1 coset 4 after coset_rep
sims::element_from_path level 1 coset 4:
cosetrep:
1 0 0 
1 1 1 
1 0 1 

sims::element_from_path level 2 coset 0 before coset_rep
sims::coset_rep i=2 j=0
sims::coset_rep i=2 j=0
cosetrep:
1 0 0 
0 1 0 
0 0 1 
sims::element_from_path level 2 coset 0 after coset_rep
sims::element_from_path level 2 coset 0:
cosetrep:
1 0 0 
0 1 0 
0 0 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 6, random element { 0, 4, 0 }
sims::transitive_extension_tolerant found an extension of order 84 of 168 with 5 strong generators
remaining factor: 2 remainder 0
sims::random_element
sims::random_element orbit_len=( 7, 6, 2 )
sims::random_element
path=( 3, 5, 1 )
sims::element_from_path
path=( 3, 5, 1 )
A->degree=7
sims::element_from_path level 0 coset 3 before coset_rep
sims::coset_rep i=0 j=3
sims::coset_rep i=0 j=3
cosetrep:
0 1 0 
1 1 1 
1 0 0 
sims::element_from_path level 0 coset 3 after coset_rep
sims::element_from_path level 0 coset 3:
cosetrep:
0 1 0 
1 1 1 
1 0 0 

sims::element_from_path level 1 coset 5 before coset_rep
sims::coset_rep i=1 j=5
sims::coset_rep i=1 j=5
cosetrep:
1 0 0 
0 1 1 
0 0 1 
sims::element_from_path level 1 coset 5 after coset_rep
sims::element_from_path level 1 coset 5:
cosetrep:
1 0 0 
0 1 1 
0 0 1 

sims::element_from_path level 2 coset 1 before coset_rep
sims::coset_rep i=2 j=1
sims::coset_rep i=2 j=1
cosetrep:
1 0 0 
0 1 0 
1 1 1 
sims::element_from_path level 2 coset 1 after coset_rep
sims::element_from_path level 2 coset 1:
cosetrep:
1 0 0 
0 1 0 
1 1 1 

sims::element_from_path done
sims::random_element done
sims::transitive_extension_tolerant choosing random coset 1, random element { 3, 5, 1 }
sims::transitive_extension_tolerant found an extension of order 168 of 168 with 6 strong generators
remaining factor: 1 remainder 0
sims::transitive_extension_tolerant extracting strong generators
extract_strong_generators_in_order
A->base_len=3
sims::extract_strong_generators_in_order done, found 6 strong generators
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )extension with point 6 : 
after upstep_for_sets/upstep_subspace_action
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )_{168}
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : ( 0, 1, 2, 3, 4, 5, 6 )_{168} (double check)
upstep_work::init_extension_node done
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : with point 6 : done 
nb_cosets_processed=2
init_extension_node returns TRUE
cur=10
Level 6 Node 8 = 0 / 1 Extension 0 / 1 : with point 6 done
upstep_work::handle_extension_unprocessed_type done
upstep_work::handle_extension prev=8 prev_ex=0 done
generator::extend_node after Work.handle_extension
generator::extend_node working on extension 0 / 1:
generator::extend_node after freeing Work
Time 0:00 : Level 6 Node 8 = 0 / 1 :  **** Upstep finished with 1 new orbits and 0 fusion nodes. We now have 1 nodes at level 7, progress: 100. 0 % 
    0 :          1 :          0 :          1 :          0
    1 :          1 :          0 :          1 :          0
    2 :          2 :          0 :          2 :          0
    3 :          2 :          1 :          3 :          0
    4 :          1 :          1 :          2 :          0
    5 :          1 :          0 :          1 :          0
    6 :          1 :          0 :          1 :          0
Time 0:00 : Level 6 Node 8 = 0 / 1 :  Upstep : progress: 100. 0 % 
generator::extend_level after upstep
generator::housekeeping verbose_level=20
##################################################################################################
Found 1 orbits at depth 7
0 : 1 orbits
1 : 1 orbits
2 : 1 orbits
3 : 2 orbits
4 : 2 orbits
5 : 1 orbits
6 : 1 orbits
7 : 1 orbits
total: 10
(168) average is 168 + 0 / 1
# 7
7 0 1 2 3 4 5 6 168 adaaaaaaagaaaaaaaaaaaaaaabaaaaaaacaaaaaaahaaaaaaagaaaaaaaeaaaaaanbabfbabfjabkbaahjabhmaa
-1 1 9 in 0:00
(168) average is 168 + 0 / 1

# in action PGL_3_2
generator_housekeeping not writing files
generator_housekeeping not writing tree
generator::housekeeping done
generator::main done
***************** The End **********************
0:00
